var searchIndex = {};
searchIndex['nphysics'] = {"items":[[0,"","nphysics","nphysics\n========\n**nphysics** is a 2 and 3-dimensional physics engine for games and animations. It uses\n[ncollide](http://ncollide.org) for collision detection, and\n[nalgebra](http://nalgebra.org) for vector/matrix math."]],"paths":[]};
searchIndex['nphysics3df64'] = {"items":[[0,"","nphysics3df64","nphysics\n========"],[0,"aliases","","Aliases for complicated parameterized types."],[4,"DefaultBroadPhase","nphysics3df64::aliases",""],[4,"DefaultCollisionDetector","",""],[0,"integration","nphysics3df64","Position and orientation update of rigid bodies."],[1,"BodyExpEulerIntegrator","nphysics3df64::integration","An explicit Euler integrator."],[1,"BodySmpEulerIntegrator","","A semi-implicit Euler integrator."],[1,"BodyForceGenerator","","A constant linear and angular force generator."],[1,"BodyDamping","","A linear and angular velocity damper."],[0,"euler","","Euler integration functions."],[3,"explicit_integrate","nphysics3df64::integration::euler","Explicit Euler integrator."],[3,"explicit_integrate_wo_rotation","","Explicit Euler integrator. This will not update the rotational components."],[3,"semi_implicit_integrate","","Semi-implicit Euler integrator."],[3,"semi_implicit_integrate_wo_rotation","","Semi-implicit Euler integrator. This will not update the rotational components."],[3,"displacement","","Computes the transformation matrix required to move an object with a `lin_vel` linear velocity,\na `ang_vil` angular velocity, and a center of mass `center_of_mass`, during the time step `dt`."],[6,"Integrator","nphysics3df64::integration","Trait implemented by every integrator."],[9,"update","","Updates the position and orientation of the object `o` after a time step of `dt`.",0],[0,"detection","nphysics3df64","Collision detection and joints."],[1,"BodiesBodies","nphysics3df64::detection","Collision detector between rigid bodies."],[1,"BodyBodyDispatcher","","Collision detector dispatcher for rigid bodies."],[1,"ActivationManager","","Structure that monitors island-based activation/deactivation of objects."],[0,"constraint","","Data structure to describe a constraint between two rigid bodies."],[2,"Constraint","nphysics3df64::detection::constraint","A constraint between two rigid bodies."],[12,"RBRB","","A contact.",1],[12,"BallInSocket","","A ball-in-socket joint.",1],[12,"Fixed","","A fixed joint.",1],[10,"clone","","",1],[0,"joint","nphysics3df64::detection","Joint handling."],[1,"Anchor","nphysics3df64::detection::joint","One of the two end points of a joint."],[11,"body","","The body attached to this anchor.",2],[11,"position","","The attach position, in local coordinates of the attached body.",2],[1,"BallInSocket","","A ball-in-socket joint."],[1,"Fixed","","A joint that prevents any relative movement (linear and angular) between two objects."],[1,"JointManager","","Structure that handles creation and removal of joints."],[6,"Joint","","Trait implemented by every joint."],[9,"anchor1","","The first anchor affected by this joint.",3],[9,"anchor2","","The second anchor affected by this joint.",3],[9,"anchor1_pos","","The first attach point in global coordinates.",3],[9,"anchor2_pos","","The second attach point in global coordinates.",3],[6,"Detector","nphysics3df64::detection","Trait implemented by collision detectors."],[9,"update","","Updates the collision detector, given an (already updated) broad-phase, and an activation\nmanager.",4],[9,"interferences","","Collects every interferences detected by this collision detector.",4],[0,"resolution","nphysics3df64","Constraint resolution."],[1,"AccumulatedImpulseSolver","nphysics3df64::resolution","Constraint solver using the projected gauss seidel algorithm and warm-starting."],[1,"Velocities","","Structure holding the result of the projected gauss seidel solver."],[11,"lv","","Linear velocity.",5],[11,"av","","Angular velocity.",5],[1,"ImpulseCache","",""],[1,"ContactIdentifier","","The identifier of a contact stored in the impulse cache."],[1,"VelocityConstraint","","A constraint of velocity at a point of contact."],[11,"normal","","The contact normal.",6],[11,"weighted_normal1","","The contact normal multiplied by the first body's inverse mass.",6],[11,"weighted_normal2","","The contact normal multiplied by the second body's inverse mass.",6],[11,"rot_axis1","","The first body rotation axis.",6],[11,"weighted_rot_axis1","","The first body rotation axis multiplied by its inverse inertia.",6],[11,"rot_axis2","","The second body rotation axis.",6],[11,"weighted_rot_axis2","","The second body rotation axis multiplied by its inverse inertia.",6],[11,"inv_projected_mass","","The inverse of the sum of linear and angular inertia of both bodies.",6],[11,"impulse","","The total impulse applied.",6],[11,"lobound","","The lower bound of the impulse.",6],[11,"hibound","","The upper bound of the impulse.",6],[11,"objective","","The target delta velocity.",6],[11,"id1","","The id of the first body.",6],[11,"id2","","The id of the second body.",6],[11,"friction_limit_id","","The id of the friction constraint.",6],[11,"friction_coeff","","The friction coefficient on this contact.",6],[2,"CorrectionMode","","The correction coefficient used by the constraint solver."],[12,"Velocity","","Penetration are solved by the penalty method.",7],[12,"VelocityAndPosition","","Penetration are solved by the penalty method together with a hard repositioning.",7],[12,"VelocityAndPositionThresold","","Penetration are solved by the penalty method together with a hard repositioning.",7],[3,"projected_gauss_seidel_solve","","Solve a set of velocity constraints using the projected gauss seidel solver."],[6,"Solver","","Trait implemented by constraint solvers."],[9,"solve","","Solve the set of constraints of type `I`.",8],[0,"world","nphysics3df64","The physics world."],[1,"World","nphysics3df64::world","The physics world."],[4,"WorldBroadPhase","","The default broad phase."],[0,"object","nphysics3df64","Rigid bodies."],[1,"RigidBody","nphysics3df64::object","The rigid body structure."],[2,"ActivationState","","The activation state of a rigid body."],[12,"Active","","The rigid body is active with a not-zero energy.",9],[12,"Inactive","","The rigid body is inactive.",9],[12,"Deleted","","The rigid body has been removed from the physics engine.",9],[2,"RigidBodyState","","The movement state of a rigid body."],[12,"Static","","The rigid body cannot move.",10],[12,"Dynamic","","The rigid body can move.",10],[0,"utils","nphysics3df64","Miscellaneous utilities."],[0,"union_find","nphysics3df64::utils","The union find algorithm."],[1,"UnionFindSet","nphysics3df64::utils::union_find","An element used by the union-find algorithm."],[3,"find","","Performs the `find` part of the union-find algorithm."],[3,"union","","Performs the `union` part of the union-find algorithm."],[10,"clone","","",11],[10,"new","","Creates a new `UnionFindSet`.",11],[10,"reinit","","Reinitialize this set.",11]],"paths":[[6,"Integrator"],[2,"Constraint"],[1,"Anchor"],[6,"Joint"],[6,"Detector"],[1,"Velocities"],[1,"VelocityConstraint"],[2,"CorrectionMode"],[6,"Solver"],[2,"ActivationState"],[2,"RigidBodyState"],[1,"UnionFindSet"]]};

searchIndex['nphysics3df32'] = {"items":[[0,"","nphysics3df32","nphysics\n========\n**nphysics** is a 2 and 3-dimensional physics engine for games and animations. It uses\n[ncollide](http://ncollide.org) for collision detection, and\n[nalgebra](http://nalgebra.org) for vector/matrix math."],[0,"aliases","","Aliases for complicated parameterized types."],[4,"DefaultBroadPhase","nphysics3df32::aliases",""],[4,"DefaultCollisionDetector","",""],[0,"integration","nphysics3df32","Position and orientation update of rigid bodies."],[1,"BodyExpEulerIntegrator","nphysics3df32::integration","An explicit Euler integrator."],[1,"BodySmpEulerIntegrator","","A semi-implicit Euler integrator."],[1,"BodyForceGenerator","","A constant linear and angular force generator."],[1,"BodyDamping","","A linear and angular velocity damper."],[0,"euler","","Euler integration functions."],[3,"explicit_integrate","nphysics3df32::integration::euler","Explicit Euler integrator."],[3,"explicit_integrate_wo_rotation","","Explicit Euler integrator. This will not update the rotational components."],[3,"semi_implicit_integrate","","Semi-implicit Euler integrator."],[3,"semi_implicit_integrate_wo_rotation","","Semi-implicit Euler integrator. This will not update the rotational components."],[3,"displacement","","Computes the transformation matrix required to move an object with a `lin_vel` linear velocity,\na `ang_vil` angular velocity, and a center of mass `center_of_mass`, during the time step `dt`."],[6,"Integrator","nphysics3df32::integration","Trait implemented by every integrator."],[9,"update","","Updates the position and orientation of the object `o` after a time step of `dt`.",0],[0,"detection","nphysics3df32","Collision detection and joints."],[1,"BodiesBodies","nphysics3df32::detection","Collision detector between rigid bodies."],[1,"BodyBodyDispatcher","","Collision detector dispatcher for rigid bodies."],[1,"ActivationManager","","Structure that monitors island-based activation/deactivation of objects."],[0,"constraint","","Data structure to describe a constraint between two rigid bodies."],[2,"Constraint","nphysics3df32::detection::constraint","A constraint between two rigid bodies."],[12,"RBRB","","A contact.",1],[12,"BallInSocket","","A ball-in-socket joint.",1],[12,"Fixed","","A fixed joint.",1],[10,"clone","","",1],[0,"joint","nphysics3df32::detection","Joint handling."],[1,"Anchor","nphysics3df32::detection::joint","One of the two end points of a joint."],[11,"body","","The body attached to this anchor.",2],[11,"position","","The attach position, in local coordinates of the attached body.",2],[1,"BallInSocket","","A ball-in-socket joint."],[1,"Fixed","","A joint that prevents any relative movement (linear and angular) between two objects."],[1,"JointManager","","Structure that handles creation and removal of joints."],[6,"Joint","","Trait implemented by every joint."],[9,"anchor1","","The first anchor affected by this joint.",3],[9,"anchor2","","The second anchor affected by this joint.",3],[9,"anchor1_pos","","The first attach point in global coordinates.",3],[9,"anchor2_pos","","The second attach point in global coordinates.",3],[6,"Detector","nphysics3df32::detection","Trait implemented by collision detectors."],[9,"update","","Updates the collision detector, given an (already updated) broad-phase, and an activation\nmanager.",4],[9,"interferences","","Collects every interferences detected by this collision detector.",4],[0,"resolution","nphysics3df32","Constraint resolution."],[1,"AccumulatedImpulseSolver","nphysics3df32::resolution","Constraint solver using the projected gauss seidel algorithm and warm-starting."],[1,"Velocities","","Structure holding the result of the projected gauss seidel solver."],[11,"lv","","Linear velocity.",5],[11,"av","","Angular velocity.",5],[1,"ImpulseCache","",""],[1,"ContactIdentifier","","The identifier of a contact stored in the impulse cache."],[1,"VelocityConstraint","","A constraint of velocity at a point of contact."],[11,"normal","","The contact normal.",6],[11,"weighted_normal1","","The contact normal multiplied by the first body's inverse mass.",6],[11,"weighted_normal2","","The contact normal multiplied by the second body's inverse mass.",6],[11,"rot_axis1","","The first body rotation axis.",6],[11,"weighted_rot_axis1","","The first body rotation axis multiplied by its inverse inertia.",6],[11,"rot_axis2","","The second body rotation axis.",6],[11,"weighted_rot_axis2","","The second body rotation axis multiplied by its inverse inertia.",6],[11,"inv_projected_mass","","The inverse of the sum of linear and angular inertia of both bodies.",6],[11,"impulse","","The total impulse applied.",6],[11,"lobound","","The lower bound of the impulse.",6],[11,"hibound","","The upper bound of the impulse.",6],[11,"objective","","The target delta velocity.",6],[11,"id1","","The id of the first body.",6],[11,"id2","","The id of the second body.",6],[11,"friction_limit_id","","The id of the friction constraint.",6],[11,"friction_coeff","","The friction coefficient on this contact.",6],[2,"CorrectionMode","","The correction coefficient used by the constraint solver."],[12,"Velocity","","Penetration are solved by the penalty method.",7],[12,"VelocityAndPosition","","Penetration are solved by the penalty method together with a hard repositioning.",7],[12,"VelocityAndPositionThresold","","Penetration are solved by the penalty method together with a hard repositioning.",7],[3,"projected_gauss_seidel_solve","","Solve a set of velocity constraints using the projected gauss seidel solver."],[6,"Solver","","Trait implemented by constraint solvers."],[9,"solve","","Solve the set of constraints of type `I`.",8],[0,"world","nphysics3df32","The physics world."],[1,"World","nphysics3df32::world","The physics world."],[4,"WorldBroadPhase","","The default broad phase."],[0,"object","nphysics3df32","Rigid bodies."],[1,"RigidBody","nphysics3df32::object","The rigid body structure."],[2,"ActivationState","","The activation state of a rigid body."],[12,"Active","","The rigid body is active with a not-zero energy.",9],[12,"Inactive","","The rigid body is inactive.",9],[12,"Deleted","","The rigid body has been removed from the physics engine.",9],[2,"RigidBodyState","","The movement state of a rigid body."],[12,"Static","","The rigid body cannot move.",10],[12,"Dynamic","","The rigid body can move.",10],[0,"utils","nphysics3df32","Miscellaneous utilities."],[0,"union_find","nphysics3df32::utils","The union find algorithm."],[1,"UnionFindSet","nphysics3df32::utils::union_find","An element used by the union-find algorithm."],[3,"find","","Performs the `find` part of the union-find algorithm."],[3,"union","","Performs the `union` part of the union-find algorithm."],[10,"clone","","",11],[10,"new","","Creates a new `UnionFindSet`.",11],[10,"reinit","","Reinitialize this set.",11]],"paths":[[6,"Integrator"],[2,"Constraint"],[1,"Anchor"],[6,"Joint"],[6,"Detector"],[1,"Velocities"],[1,"VelocityConstraint"],[2,"CorrectionMode"],[6,"Solver"],[2,"ActivationState"],[2,"RigidBodyState"],[1,"UnionFindSet"]]};

searchIndex['nphysics2df32'] = {"items":[[0,"","nphysics2df32","nphysics\n========\n**nphysics** is a 2 and 3-dimensional physics engine for games and animations. It uses\n[ncollide](http://ncollide.org) for collision detection, and\n[nalgebra](http://nalgebra.org) for vector/matrix math."],[0,"aliases","","Aliases for complicated parameterized types."],[4,"DefaultBroadPhase","nphysics2df32::aliases",""],[4,"DefaultCollisionDetector","",""],[0,"integration","nphysics2df32","Position and orientation update of rigid bodies."],[1,"BodyExpEulerIntegrator","nphysics2df32::integration","An explicit Euler integrator."],[1,"BodySmpEulerIntegrator","","A semi-implicit Euler integrator."],[1,"BodyForceGenerator","","A constant linear and angular force generator."],[1,"BodyDamping","","A linear and angular velocity damper."],[0,"euler","","Euler integration functions."],[3,"explicit_integrate","nphysics2df32::integration::euler","Explicit Euler integrator."],[3,"explicit_integrate_wo_rotation","","Explicit Euler integrator. This will not update the rotational components."],[3,"semi_implicit_integrate","","Semi-implicit Euler integrator."],[3,"semi_implicit_integrate_wo_rotation","","Semi-implicit Euler integrator. This will not update the rotational components."],[3,"displacement","","Computes the transformation matrix required to move an object with a `lin_vel` linear velocity,\na `ang_vil` angular velocity, and a center of mass `center_of_mass`, during the time step `dt`."],[6,"Integrator","nphysics2df32::integration","Trait implemented by every integrator."],[9,"update","","Updates the position and orientation of the object `o` after a time step of `dt`.",0],[0,"detection","nphysics2df32","Collision detection and joints."],[1,"BodiesBodies","nphysics2df32::detection","Collision detector between rigid bodies."],[1,"BodyBodyDispatcher","","Collision detector dispatcher for rigid bodies."],[1,"ActivationManager","","Structure that monitors island-based activation/deactivation of objects."],[0,"constraint","","Data structure to describe a constraint between two rigid bodies."],[2,"Constraint","nphysics2df32::detection::constraint","A constraint between two rigid bodies."],[12,"RBRB","","A contact.",1],[12,"BallInSocket","","A ball-in-socket joint.",1],[12,"Fixed","","A fixed joint.",1],[10,"clone","","",1],[0,"joint","nphysics2df32::detection","Joint handling."],[1,"Anchor","nphysics2df32::detection::joint","One of the two end points of a joint."],[11,"body","","The body attached to this anchor.",2],[11,"position","","The attach position, in local coordinates of the attached body.",2],[1,"BallInSocket","","A ball-in-socket joint."],[1,"Fixed","","A joint that prevents any relative movement (linear and angular) between two objects."],[1,"JointManager","","Structure that handles creation and removal of joints."],[6,"Joint","","Trait implemented by every joint."],[9,"anchor1","","The first anchor affected by this joint.",3],[9,"anchor2","","The second anchor affected by this joint.",3],[9,"anchor1_pos","","The first attach point in global coordinates.",3],[9,"anchor2_pos","","The second attach point in global coordinates.",3],[6,"Detector","nphysics2df32::detection","Trait implemented by collision detectors."],[9,"update","","Updates the collision detector, given an (already updated) broad-phase, and an activation\nmanager.",4],[9,"interferences","","Collects every interferences detected by this collision detector.",4],[0,"resolution","nphysics2df32","Constraint resolution."],[1,"AccumulatedImpulseSolver","nphysics2df32::resolution","Constraint solver using the projected gauss seidel algorithm and warm-starting."],[1,"Velocities","","Structure holding the result of the projected gauss seidel solver."],[11,"lv","","Linear velocity.",5],[11,"av","","Angular velocity.",5],[1,"ImpulseCache","",""],[1,"ContactIdentifier","","The identifier of a contact stored in the impulse cache."],[1,"VelocityConstraint","","A constraint of velocity at a point of contact."],[11,"normal","","The contact normal.",6],[11,"weighted_normal1","","The contact normal multiplied by the first body's inverse mass.",6],[11,"weighted_normal2","","The contact normal multiplied by the second body's inverse mass.",6],[11,"rot_axis1","","The first body rotation axis.",6],[11,"weighted_rot_axis1","","The first body rotation axis multiplied by its inverse inertia.",6],[11,"rot_axis2","","The second body rotation axis.",6],[11,"weighted_rot_axis2","","The second body rotation axis multiplied by its inverse inertia.",6],[11,"inv_projected_mass","","The inverse of the sum of linear and angular inertia of both bodies.",6],[11,"impulse","","The total impulse applied.",6],[11,"lobound","","The lower bound of the impulse.",6],[11,"hibound","","The upper bound of the impulse.",6],[11,"objective","","The target delta velocity.",6],[11,"id1","","The id of the first body.",6],[11,"id2","","The id of the second body.",6],[11,"friction_limit_id","","The id of the friction constraint.",6],[11,"friction_coeff","","The friction coefficient on this contact.",6],[2,"CorrectionMode","","The correction coefficient used by the constraint solver."],[12,"Velocity","","Penetration are solved by the penalty method.",7],[12,"VelocityAndPosition","","Penetration are solved by the penalty method together with a hard repositioning.",7],[12,"VelocityAndPositionThresold","","Penetration are solved by the penalty method together with a hard repositioning.",7],[3,"projected_gauss_seidel_solve","","Solve a set of velocity constraints using the projected gauss seidel solver."],[6,"Solver","","Trait implemented by constraint solvers."],[9,"solve","","Solve the set of constraints of type `I`.",8],[0,"world","nphysics2df32","The physics world."],[1,"World","nphysics2df32::world","The physics world."],[4,"WorldBroadPhase","","The default broad phase."],[0,"object","nphysics2df32","Rigid bodies."],[1,"RigidBody","nphysics2df32::object","The rigid body structure."],[2,"ActivationState","","The activation state of a rigid body."],[12,"Active","","The rigid body is active with a not-zero energy.",9],[12,"Inactive","","The rigid body is inactive.",9],[12,"Deleted","","The rigid body has been removed from the physics engine.",9],[2,"RigidBodyState","","The movement state of a rigid body."],[12,"Static","","The rigid body cannot move.",10],[12,"Dynamic","","The rigid body can move.",10],[0,"utils","nphysics2df32","Miscellaneous utilities."],[0,"union_find","nphysics2df32::utils","The union find algorithm."],[1,"UnionFindSet","nphysics2df32::utils::union_find","An element used by the union-find algorithm."],[3,"find","","Performs the `find` part of the union-find algorithm."],[3,"union","","Performs the `union` part of the union-find algorithm."],[10,"clone","","",11],[10,"new","","Creates a new `UnionFindSet`.",11],[10,"reinit","","Reinitialize this set.",11]],"paths":[[6,"Integrator"],[2,"Constraint"],[1,"Anchor"],[6,"Joint"],[6,"Detector"],[1,"Velocities"],[1,"VelocityConstraint"],[2,"CorrectionMode"],[6,"Solver"],[2,"ActivationState"],[2,"RigidBodyState"],[1,"UnionFindSet"]]};

searchIndex['nphysics2df64'] = {"items":[[0,"","nphysics2df64","nphysics\n========\n**nphysics** is a 2 and 3-dimensional physics engine for games and animations. It uses\n[ncollide](http://ncollide.org) for collision detection, and\n[nalgebra](http://nalgebra.org) for vector/matrix math."],[0,"aliases","","Aliases for complicated parameterized types."],[4,"DefaultBroadPhase","nphysics2df64::aliases",""],[4,"DefaultCollisionDetector","",""],[0,"integration","nphysics2df64","Position and orientation update of rigid bodies."],[1,"BodyExpEulerIntegrator","nphysics2df64::integration","An explicit Euler integrator."],[1,"BodySmpEulerIntegrator","","A semi-implicit Euler integrator."],[1,"BodyForceGenerator","","A constant linear and angular force generator."],[1,"BodyDamping","","A linear and angular velocity damper."],[0,"euler","","Euler integration functions."],[3,"explicit_integrate","nphysics2df64::integration::euler","Explicit Euler integrator."],[3,"explicit_integrate_wo_rotation","","Explicit Euler integrator. This will not update the rotational components."],[3,"semi_implicit_integrate","","Semi-implicit Euler integrator."],[3,"semi_implicit_integrate_wo_rotation","","Semi-implicit Euler integrator. This will not update the rotational components."],[3,"displacement","","Computes the transformation matrix required to move an object with a `lin_vel` linear velocity,\na `ang_vil` angular velocity, and a center of mass `center_of_mass`, during the time step `dt`."],[6,"Integrator","nphysics2df64::integration","Trait implemented by every integrator."],[9,"update","","Updates the position and orientation of the object `o` after a time step of `dt`.",0],[0,"detection","nphysics2df64","Collision detection and joints."],[1,"BodiesBodies","nphysics2df64::detection","Collision detector between rigid bodies."],[1,"BodyBodyDispatcher","","Collision detector dispatcher for rigid bodies."],[1,"ActivationManager","","Structure that monitors island-based activation/deactivation of objects."],[0,"constraint","","Data structure to describe a constraint between two rigid bodies."],[2,"Constraint","nphysics2df64::detection::constraint","A constraint between two rigid bodies."],[12,"RBRB","","A contact.",1],[12,"BallInSocket","","A ball-in-socket joint.",1],[12,"Fixed","","A fixed joint.",1],[10,"clone","","",1],[0,"joint","nphysics2df64::detection","Joint handling."],[1,"Anchor","nphysics2df64::detection::joint","One of the two end points of a joint."],[11,"body","","The body attached to this anchor.",2],[11,"position","","The attach position, in local coordinates of the attached body.",2],[1,"BallInSocket","","A ball-in-socket joint."],[1,"Fixed","","A joint that prevents any relative movement (linear and angular) between two objects."],[1,"JointManager","","Structure that handles creation and removal of joints."],[6,"Joint","","Trait implemented by every joint."],[9,"anchor1","","The first anchor affected by this joint.",3],[9,"anchor2","","The second anchor affected by this joint.",3],[9,"anchor1_pos","","The first attach point in global coordinates.",3],[9,"anchor2_pos","","The second attach point in global coordinates.",3],[6,"Detector","nphysics2df64::detection","Trait implemented by collision detectors."],[9,"update","","Updates the collision detector, given an (already updated) broad-phase, and an activation\nmanager.",4],[9,"interferences","","Collects every interferences detected by this collision detector.",4],[0,"resolution","nphysics2df64","Constraint resolution."],[1,"AccumulatedImpulseSolver","nphysics2df64::resolution","Constraint solver using the projected gauss seidel algorithm and warm-starting."],[1,"Velocities","","Structure holding the result of the projected gauss seidel solver."],[11,"lv","","Linear velocity.",5],[11,"av","","Angular velocity.",5],[1,"ImpulseCache","",""],[1,"ContactIdentifier","","The identifier of a contact stored in the impulse cache."],[1,"VelocityConstraint","","A constraint of velocity at a point of contact."],[11,"normal","","The contact normal.",6],[11,"weighted_normal1","","The contact normal multiplied by the first body's inverse mass.",6],[11,"weighted_normal2","","The contact normal multiplied by the second body's inverse mass.",6],[11,"rot_axis1","","The first body rotation axis.",6],[11,"weighted_rot_axis1","","The first body rotation axis multiplied by its inverse inertia.",6],[11,"rot_axis2","","The second body rotation axis.",6],[11,"weighted_rot_axis2","","The second body rotation axis multiplied by its inverse inertia.",6],[11,"inv_projected_mass","","The inverse of the sum of linear and angular inertia of both bodies.",6],[11,"impulse","","The total impulse applied.",6],[11,"lobound","","The lower bound of the impulse.",6],[11,"hibound","","The upper bound of the impulse.",6],[11,"objective","","The target delta velocity.",6],[11,"id1","","The id of the first body.",6],[11,"id2","","The id of the second body.",6],[11,"friction_limit_id","","The id of the friction constraint.",6],[11,"friction_coeff","","The friction coefficient on this contact.",6],[2,"CorrectionMode","","The correction coefficient used by the constraint solver."],[12,"Velocity","","Penetration are solved by the penalty method.",7],[12,"VelocityAndPosition","","Penetration are solved by the penalty method together with a hard repositioning.",7],[12,"VelocityAndPositionThresold","","Penetration are solved by the penalty method together with a hard repositioning.",7],[3,"projected_gauss_seidel_solve","","Solve a set of velocity constraints using the projected gauss seidel solver."],[6,"Solver","","Trait implemented by constraint solvers."],[9,"solve","","Solve the set of constraints of type `I`.",8],[0,"world","nphysics2df64","The physics world."],[1,"World","nphysics2df64::world","The physics world."],[4,"WorldBroadPhase","","The default broad phase."],[0,"object","nphysics2df64","Rigid bodies."],[1,"RigidBody","nphysics2df64::object","The rigid body structure."],[2,"ActivationState","","The activation state of a rigid body."],[12,"Active","","The rigid body is active with a not-zero energy.",9],[12,"Inactive","","The rigid body is inactive.",9],[12,"Deleted","","The rigid body has been removed from the physics engine.",9],[2,"RigidBodyState","","The movement state of a rigid body."],[12,"Static","","The rigid body cannot move.",10],[12,"Dynamic","","The rigid body can move.",10],[0,"utils","nphysics2df64","Miscellaneous utilities."],[0,"union_find","nphysics2df64::utils","The union find algorithm."],[1,"UnionFindSet","nphysics2df64::utils::union_find","An element used by the union-find algorithm."],[3,"find","","Performs the `find` part of the union-find algorithm."],[3,"union","","Performs the `union` part of the union-find algorithm."],[10,"clone","","",11],[10,"new","","Creates a new `UnionFindSet`.",11],[10,"reinit","","Reinitialize this set.",11]],"paths":[[6,"Integrator"],[2,"Constraint"],[1,"Anchor"],[6,"Joint"],[6,"Detector"],[1,"Velocities"],[1,"VelocityConstraint"],[2,"CorrectionMode"],[6,"Solver"],[2,"ActivationState"],[2,"RigidBodyState"],[1,"UnionFindSet"]]};

searchIndex['ncollide3df32'] = {"items":[[0,"","ncollide3df32","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide3df32::bounding_volume","An Axis Aligned Bounding Box."],[1,"BoundingSphere","","A Bounding Sphere."],[1,"SpacializedCone","","A normal cone with a bounding sphere."],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",0],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",1],[9,"contains","","Checks if this bounding volume contains another one.",1],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",1],[9,"merged","","Merges this bounding volume with another one.",1],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",2],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",2],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",3],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",4],[0,"geom","ncollide3df32","Geometric primitives."],[1,"Ball","ncollide3df32::geom","A Ball geometry."],[1,"Plane","","Implicit description of a plane."],[1,"Cuboid","","Geometry of a box."],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[1,"Convex","","Set of point assumed to form a convex polytope."],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[1,"Compound","","A compound geometry with an aabb bounding volume."],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[1,"Segment","","A segment geometry."],[1,"Triangle","","A triangle geometry."],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[1,"Torus","","A torus."],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",5],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",5],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",6],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",7],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",7],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",7],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",7],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",7],[0,"ray","ncollide3df32","Ray casting utilities."],[1,"Ray","ncollide3df32::ray","A Ray."],[11,"orig","","Starting point of the ray.",8],[11,"dir","","Direction of the ray.",8],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",9],[11,"normal","","The normal at the intersection point.",9],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",9],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[3,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",10],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",10],[10,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this geometry and a ray.",10],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",10],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",10],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",10],[10,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\ngeometry and a ray.",10],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",10],[0,"narrow","ncollide3df32","Narrow phases."],[1,"Contact","ncollide3df32::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",11],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",11],[11,"normal","","Contact normal",11],[11,"depth","","Penetration depth",11],[1,"Empty","","A collision detector that does nothing."],[1,"BallBall","","Collision detector between two balls."],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"ball_ball","ncollide3df32::narrow::toi","Computes the Time Of Impact of two balls."],[3,"plane_implicit","","Computes the Time Of Impact of a geometry and a plane."],[3,"implicit_implicit","","Computes the Time Of Impact of two geometries."],[3,"implicit_implicit_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide3df32::narrow","Functions to compute one contact point between two geometries."],[3,"ball_ball","ncollide3df32::narrow::collide","Computes the contact point between two balls."],[3,"plane_implicit","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"implicit_implicit","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide3df32::narrow","Functions to compute the closest points between two geometries."],[3,"ball_ball","ncollide3df32::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide3df32::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide3df32::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide3df32::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",12],[9,"translate_by","","Translates each point of this simplex.",12],[9,"add_point","","Adds a point to the simplex.",12],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",12],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",12],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",12],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",12],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",12],[0,"johnson_simplex","ncollide3df32::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide3df32::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[10,"clone","","",13],[10,"decode","","",14],[10,"encode","","",14],[10,"clone","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",14],[10,"new","","Creates a new, empty, Johnson simplex.",13],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",13],[10,"reset","","",13],[10,"dimension","","",13],[10,"max_sq_len","","",13],[10,"contains_point","","",13],[10,"add_point","","",13],[10,"project_origin_and_reduce","","",13],[10,"project_origin","","",13],[10,"translate_by","","",13],[0,"gjk","ncollide3df32::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide3df32::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",15],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",15],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",15],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",15],[10,"decode","","",15],[10,"encode","","",15],[0,"minkowski_sampling","ncollide3df32::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide3df32::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide3df32::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide3df32::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",16],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",16],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",16],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",16],[10,"clone","","",17],[10,"new","","Creates a new `YesSirSurfaceSelector`.",17],[10,"set_max_lmd","","",17],[10,"is_flat","","",17],[10,"may_contain_a_closest_point","","",17],[10,"create_test_data","","",17],[10,"clone","","",18],[10,"new","","Creates a new hyperplane-based surface selector.",18],[10,"set_max_lmd","","",18],[10,"is_flat","","",18],[10,"may_contain_a_closest_point","","",18],[10,"create_test_data","","",18],[10,"clone","","",19],[10,"new","","Creates a new tangent-cone based surface detector.",19],[10,"set_max_lmd","","",19],[10,"is_flat","","",19],[10,"may_contain_a_closest_point","","",19],[10,"create_test_data","","",19],[0,"surface_subdivision_tree","ncollide3df32::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide3df32::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[10,"clone","","",20],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",20],[10,"deref","","",20],[10,"drop","","",20],[10,"new","","Creates a new surface subdivision tree cache.",21],[10,"clear","","Removes everything from this cache.",21],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",21],[10,"new_orphan","","Creates a new tree with no parent nor children.",22],[10,"surface","","The surface contained by this node.",22],[10,"data","","Reference to the data contained by this node.",22],[10,"data_mut","","Mutable reference to the data contained by this node.",22],[10,"timestamp","","The timestamp of this tree node.",22],[10,"set_timestamp","","Sets the timestamp of this tree node.",22],[10,"has_left_child","","Whether or not this node has a left child.",22],[10,"has_right_child","","Whether or not this node has a right child.",22],[10,"right_child","","A copy of this node right child.",22],[10,"left_child","","A copy of this node left child.",22],[10,"right_child_ref","","A reference to this node right child.",22],[10,"left_child_ref","","A reference to this node left child.",22],[10,"set_right_child","","Sets the right child of this node.",22],[10,"set_left_child","","Sets the left child of this node.",22],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",22],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",22],[10,"remove_right_child","","Removes the right child of this node.",22],[10,"remove_left_child","","Removes the left child of this node.",22],[6,"CollisionDetector","ncollide3df32::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",23],[9,"num_colls","","The number of collision detected during the last update.",23],[9,"colls","","Collects the collisions detected during the last update.",23],[9,"toi","","Computes the time of impact of two objects.",23],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",24],[9,"num_colls","","The number of collision detected during the last update.",24],[9,"colls","","Collects the collisions detected during the last update.",24],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",25],[0,"broad","ncollide3df32","Broad phases."],[1,"NoIdDispatcher","ncollide3df32::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",26],[9,"remove","","Removes an element from this broad phase.",26],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",26],[9,"update_object","","Updates the collision pairs involving one specific object.",26],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",27],[9,"deactivate","","Marks and object as inactive.",27],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",27],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",27],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",28],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",29],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",30],[9,"is_valid","","Tells whether a collision between two bodies can occur.",30],[0,"volumetric","ncollide3df32","Volume and inertia tensor computation."],[3,"ball_volume","ncollide3df32::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide3df32::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",31],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",31],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",31],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inertia tensor."],[9,"surface","","Computes the surface of this object.",32],[9,"volume","","Computes the volume of this object.",32],[9,"center_of_mass","","Computes the center of mass of this object.",32],[9,"unit_angular_inertia","","Computes the angular inertia tensor of this object.",32],[10,"mass","","Given its density, this computes the mass of this object.",32],[10,"angular_inertia","","Given its mass, this computes the angular inertia of this object.",32],[10,"mass_properties","","Given its density, this computes the mass, center of mass, and inertia tensor of this object.",32],[0,"implicit","ncollide3df32","Definition of support functions."],[3,"cso_support_point","ncollide3df32::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[3,"point_cloud_support_point","","Computes the support point of a cloud of points."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",33],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",33],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",34],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",35],[0,"parametric","ncollide3df32","Definition of parametric surfaces."],[6,"ParametricSurface","ncollide3df32::parametric","Trait implemented by differentiable parametric surfaces."],[9,"at","","Evaluates the parametric surface.",36],[9,"at_u","","Evaluates the surface derivative wrt. `u`.",36],[9,"at_v","","Evaluates the surface derivative wrt. `v`.",36],[9,"at_uu","","Evaluates the surface second derivative wrt. `u`.",36],[9,"at_vv","","Evaluates the surface second derivative wrt. `v`.",36],[9,"at_uv","","Evaluates the surface second derivative wrt. `u` and `v`.",36],[10,"at_u_v","","Evaluates the parametric surface and its first derivatives.",36],[10,"at_u_v_uu_vv_uv","","Evaluates the parametric surface and its first and second derivatides.",36],[9,"at_uv_nk","","Evaluates the parametric surface and its derivative wrt. `u` `n` times and wrt. `v` `k` times.",36],[10,"at_uv_nk_all","","Evaluates all the partial derivatives of the surface, up to the `n`-th derivative.",36],[0,"partitioning","ncollide3df32","Spatial partitioning tools."],[1,"DBVT","ncollide3df32::partitioning","A Dynamic Bounding Volume Tree."],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",37],[11,"center","","The center of this node bounding volume.",37],[11,"object","","An user-defined object.",37],[11,"parent","","This node parent.",37],[1,"BVT","","A Boundig Volume Tree."],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",38],[12,"LeftChildOf","","This leaf is the left child of another node.",38],[12,"Detached","","This leaf is detached from any tree.",38],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",39],[12,"Parts","","Result of the partitioning of several elements.",39],[2,"BVTNode","","A node of the bounding volume tree."],[12,"Internal","","An internal node.",40],[12,"Leaf","","A leaf.",40],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[3,"kdtree_partitioner_with_centers","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",41],[9,"visit_leaf","","Visits a leaf.",41],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",41],[10,"visit_leaf_mut","","Visits a leaf.",41],[6,"BVTTVisitor","","Visitor for the Bounding Volume Traversal Tree."],[9,"visit_internal_internal","","Visit two internal nodes.",42],[9,"visit_leaf_leaf","","Visit two leaves.",42],[9,"visit_internal_leaf","","Visit one internal node and one leaf.",42],[9,"visit_leaf_internal","","Visit one leaf and on internal node.",42],[0,"procedural","ncollide3df32","Procedural mesh generation."],[1,"TriMesh","ncollide3df32::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",43],[11,"normals","","Coordinates of the mesh normals.",43],[11,"uvs","","Textures coordinates of the mesh.",43],[11,"indices","","Index buffer of the mesh.",43],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",44],[11,"normals","","Coordinates of the polyline normals.",44],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",45],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",45],[3,"parametric_surface_uniform","","Meshing algorithm that uniformly triangulates the parametric space."],[3,"parametric_surface_uniform_with_distance_error","","Uniformly triangulates the parametric space."],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[3,"convex_hull3d","","Computes the convex hull of a set of 3d points."],[3,"convex_hull2d","","Computes the convex hull of a set of 2d points."],[3,"convex_hull2d_idx","","Computes the convex hull of a set of 2d points and returns only the indices of the hull\nvertices."],[3,"hacd","","Approximate convex decomposition of a triangle mesh."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide3df32::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[3,"split_index_buffer_and_recover_topology","","Duplicates the indices of each triangle on the given index buffer, giving the same id to each\nidentical vertex."],[0,"path","ncollide3df32::procedural","Path generation."],[1,"PolylinePattern","ncollide3df32::procedural::path","A pattern composed of polyline and two caps."],[1,"PolylinePath","","A path with its sample points given by a polyline."],[1,"ArrowheadCap","","A cap that looks like an arrow."],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",46],[12,"InnerPoint","","A point that is inside of the path currently generated.",46],[12,"EndPoint","","A point that ends the path currently generated.",46],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",46],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",47],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",48],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",49],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",49],[6,"ToTriMesh","ncollide3df32::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",50],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",51],[0,"utils","ncollide3df32","Miscelaneous, unsorted generic geometric utilities."],[1,"BacktrackingLineSearch","ncollide3df32::utils","The backtracking line search method."],[1,"HashablePartialEq","","A structure that implements `Eq` and is hashable even if the wrapped data implements only\n`PartialEq`."],[3,"center","","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[3,"is_affinely_dependent_triangle","","Tests if three points are exactly aligned."],[3,"is_point_in_triangle","","Tests if a point is inside of a triangle."],[3,"triangle_area","","Computes the area of a triangle."],[3,"triangle_perimeter","","Computes the perimeter of a triangle."],[3,"tetrahedron_volume","","Computes the volume of a tetrahedron."],[3,"tetrahedron_signed_volume","","Computes the signed volume of a tetrahedron."],[3,"tetrahedron_center","","Computes the center of a tetrahedron."],[3,"remove_unused_points","","Given an index buffer, remove from `points` every point that is not indexed."],[3,"dcos","","Computes the n-th derivative of the cosinus function."],[3,"dsin","","Computes the n-th derivative of the sinus function."],[3,"binom","","Computes the binomial coefficient C^k_n (\"k among n\")."],[3,"maximize_with_newton","","Maximizes a real function using the Newton method."],[3,"newton","","Finds the root of a function using the Newton method."],[3,"minimize_with_bfgs","","Minimizes a function using the bfgs method."],[3,"bfgs","","Minimizes a function using the quasi-newton BFGS method."],[3,"cov","","Computes the convariance matrix of a set of points."],[3,"cov_and_center","","Computes the covariance matrix and center of a set of points."],[3,"center_reduce","","Centers and reduces a set of data."],[3,"sort3","","Sorts a set of three values in increasing order."],[0,"symbolic","","Basic symbolic computation system."],[1,"Deriv","ncollide3df32::utils::symbolic","The derivative of `A`."],[1,"DerivU","","The derivative of `A` wrt. `u`."],[1,"DerivV","","The derivative of `A` wrt. `v`."],[1,"SymComp","","The composition operator."],[1,"SymMult","","The multiplication operator."],[1,"SymAdd","","The addition operator."],[1,"SymSub","","The subtraction operator."],[1,"SymNeg","","The negation operator."],[1,"T","","A univariate function of `T`."],[1,"U","","A bivariate function of `U`."],[1,"V","","A bivariate function of `V`."],[1,"Sin","","The sinus function."],[1,"Cos","","The cosinus function."],[1,"Exp","","The exponential function."],[1,"Poly1","","A polynomial function."],[1,"Poly2","","A polynomial function."],[1,"Poly3","","A polynomial function."],[1,"Poly4","","A polynomial function."],[1,"Poly5","","A polynomial function."],[1,"Poly6","","A polynomial function."],[3,"deriv","","The derivative of `A`."],[3,"deriv_u","","The derivative of `A` wrt. `u`."],[3,"deriv_v","","The derivative of `A` wrt. `v`."],[3,"comp","","Symbolic representation of the composition of two functions."],[3,"mult","","Symbolic representation of the multiplication of two functions."],[3,"add","","Symbolic representation of the addition of two functions."],[3,"sub","","Symbolic representation of the subtraction of two functions."],[3,"neg","","Symbolic representation of the negation of a function."],[3,"t","","A univariate function of `t`."],[3,"u","","A bivariate function of `u`."],[3,"v","","A bivariate function of `v`."],[3,"sin","","The sinus function."],[3,"cos","","The cosinus function."],[3,"exp","","The exponential function."],[3,"t1","","A polynomial function."],[3,"t2","","A polynomial function."],[3,"t3","","A polynomial function."],[3,"t4","","A polynomial function."],[3,"t5","","A polynomial function."],[3,"t6","","A polynomial function."],[6,"UnivariateFn","","Trait implemented by smooth univariate functions."],[9,"d0","","Evaluates the function.",52],[10,"ueval","","Same as `d0`.",52],[9,"d1","","Evaluates the first derivative.",52],[9,"d2","","Evaluates the second derivative.",52],[9,"dn","","Evaluates the n-th derivative.",52],[10,"d0_1","","Evaluates the function and its first derivative.",52],[10,"d0_1_2","","Evaluates the function and its first two derivatives.",52],[10,"dn_all","","Evaluates the function and all its derivative, up to the n-th (included).",52],[6,"BivariateFn","","Trait implemented by smooth bivariate functions."],[9,"d0","","Evaluates the function.",53],[10,"beval","","Same as `d0`.",53],[9,"du","","Evaluates the first derivative wrt. `u`.",53],[9,"dv","","Evaluates the firt derivative wrt. `v`.",53],[9,"duu","","Evaluates the second derivative wrt. `u`.",53],[9,"dvv","","Evaluates the second derivative wrt. `v`.",53],[9,"duv","","Evaluates the second derivative wrt. `u` and `v`.",53],[9,"duv_nk","","Evaluate the n-th derivative wrt. `u` and k-th derivative wrt. `v`.",53],[10,"duv_nk_all","","Evaluate all the n-th derivative wrt. `u` and k-th derivative wrt. `v`.",53],[6,"LineSearch","ncollide3df32::utils","Trait for line search methods."],[9,"step_size","","Gets a near-optimal step size for the next descent.",54],[6,"AnyPrivate","",""],[9,"get_dyn_type_id","","The type id of `Self`.",55],[6,"AsBytes","","Trait that transforms thing to a slice of u8."],[9,"as_bytes","","",56],[0,"data","ncollide3df32","Data structure utilities."],[0,"pair","ncollide3df32::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide3df32::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",57],[11,"second","","second object of the pair",57],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[10,"decode","","",57],[10,"encode","","",57],[10,"clone","","",57],[10,"new","","Builds a new `Pair`.",57],[10,"eq","","",57],[10,"decode","","",58],[10,"encode","","",58],[10,"new","","Creates a new PairTWHash",58],[10,"hash","","",58],[0,"hash","ncollide3df32::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide3df32::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[1,"UintTWHash","","Hash function for `uint`."],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",59],[10,"decode","","",60],[10,"encode","","",60],[10,"clone","","",60],[10,"new","","Creates a new UintPairTWHash.",60],[10,"hash","","",60],[10,"decode","","",61],[10,"encode","","",61],[10,"clone","","",61],[10,"new","","Creates a new UintTWHash.",61],[10,"hash","","",61],[0,"hash_map","ncollide3df32::data","An hash map with a customizable hash function."],[1,"Entry","ncollide3df32::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",62],[11,"value","","The value of the entry.",62],[1,"HashMap","","Alternative implementation of `HashMap`."],[10,"decode","","",62],[10,"encode","","",62],[10,"clone","","",62],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"new","","Creates a new hash map.",63],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",63],[10,"elements","","The elements added to this hash map.",63],[10,"elements_mut","","The elements added to this hash map.",63],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",63],[10,"get_and_remove","","Removes an element and returns its value if it existed.",63],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",63],[10,"insert_or_replace","","Inserts or replace an element.",63],[10,"len","","",63],[10,"clear","","",63],[10,"contains_key","","",63],[10,"find","","",63],[10,"insert","","Inserts an element on the hash map.",63],[10,"remove","","Remove an element from the hash map.",63],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",63],[0,"owned_allocation_cache","ncollide3df32::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide3df32::data::owned_allocation_cache","Cache for owned objects."],[10,"new","","Initializes the cache.",64],[10,"alloc","","Box a value into a potentially already allocated box.",64],[10,"retain","","Retains a box which can be re-used by the `box` method.",64],[10,"clear","","Clears the cache, destroying any stored pointer.",64],[0,"has_uid","ncollide3df32::data","Objects with an unique identifier."],[6,"HasUid","ncollide3df32::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",65],[10,"uid","std::gc","",66],[10,"uid","alloc::rc","",67],[10,"uid","alloc::arc","",68],[0,"vec_slice","ncollide3df32::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide3df32::data::vec_slice","A vector slice with a specific length and stride."],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[10,"len","","",69],[10,"is_empty","","",69],[10,"len","","",70],[10,"is_empty","","",70],[10,"new","","Creates a new immutable slice.",69],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",69],[10,"get","","Gets the i-th element of the slice.",69],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",69],[10,"new","","Creates a new mutable slice.",70],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",70],[10,"as_slice","","Creates an immutable slice from this mutable slice.",70],[10,"get","","Gets the i-th element of the slice.",70],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",70],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",70],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",70],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",70],[0,"math","ncollide3df32","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide3df32::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",71],[10,"to_world_space","","",71],[10,"to_relative_wrt_point","","",71]],"paths":[[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[6,"ParametricSurface"],[1,"DBVTLeaf"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[2,"BVTNode"],[6,"BVTVisitor"],[6,"BVTTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[6,"UnivariateFn"],[6,"BivariateFn"],[6,"LineSearch"],[6,"AnyPrivate"],[6,"AsBytes"],[1,"Pair"],[1,"PairTWHash"],[6,"HashFun"],[1,"UintPairTWHash"],[1,"UintTWHash"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};

searchIndex['ncollide2df64'] = {"items":[[0,"","ncollide2df64","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide2df64::bounding_volume","An Axis Aligned Bounding Box."],[1,"BoundingSphere","","A Bounding Sphere."],[1,"SpacializedCone","","A normal cone with a bounding sphere."],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",0],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",1],[9,"contains","","Checks if this bounding volume contains another one.",1],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",1],[9,"merged","","Merges this bounding volume with another one.",1],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",2],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",2],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",3],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",4],[0,"geom","ncollide2df64","Geometric primitives."],[1,"Ball","ncollide2df64::geom","A Ball geometry."],[1,"Plane","","Implicit description of a plane."],[1,"Cuboid","","Geometry of a box."],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[1,"Convex","","Set of point assumed to form a convex polyline."],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[1,"Compound","","A compound geometry with an aabb bounding volume."],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[1,"Segment","","A segment geometry."],[1,"Triangle","","A triangle geometry."],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[1,"Torus","","A torus."],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",5],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",5],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",6],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",7],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",7],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",7],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",7],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",7],[0,"ray","ncollide2df64","Ray casting utilities."],[1,"Ray","ncollide2df64::ray","A Ray."],[11,"orig","","Starting point of the ray.",8],[11,"dir","","Direction of the ray.",8],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",9],[11,"normal","","The normal at the intersection point.",9],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",9],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[3,"triangle_ray_intersection","","Not yet implemented in dimensions other than 3."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",10],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",10],[10,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this geometry and a ray.",10],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",10],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",10],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",10],[10,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\ngeometry and a ray.",10],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",10],[0,"narrow","ncollide2df64","Narrow phases."],[1,"Contact","ncollide2df64::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",11],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",11],[11,"normal","","Contact normal",11],[11,"depth","","Penetration depth",11],[1,"Empty","","A collision detector that does nothing."],[1,"BallBall","","Collision detector between two balls."],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"ball_ball","ncollide2df64::narrow::toi","Computes the Time Of Impact of two balls."],[3,"plane_implicit","","Computes the Time Of Impact of a geometry and a plane."],[3,"implicit_implicit","","Computes the Time Of Impact of two geometries."],[3,"implicit_implicit_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide2df64::narrow","Functions to compute one contact point between two geometries."],[3,"ball_ball","ncollide2df64::narrow::collide","Computes the contact point between two balls."],[3,"plane_implicit","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"implicit_implicit","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide2df64::narrow","Functions to compute the closest points between two geometries."],[3,"ball_ball","ncollide2df64::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide2df64::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide2df64::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide2df64::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",12],[9,"translate_by","","Translates each point of this simplex.",12],[9,"add_point","","Adds a point to the simplex.",12],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",12],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",12],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",12],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",12],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",12],[0,"johnson_simplex","ncollide2df64::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide2df64::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[10,"clone","","",13],[10,"decode","","",14],[10,"encode","","",14],[10,"clone","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",14],[10,"new","","Creates a new, empty, Johnson simplex.",13],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",13],[10,"reset","","",13],[10,"dimension","","",13],[10,"max_sq_len","","",13],[10,"contains_point","","",13],[10,"add_point","","",13],[10,"project_origin_and_reduce","","",13],[10,"project_origin","","",13],[10,"translate_by","","",13],[0,"gjk","ncollide2df64::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide2df64::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",15],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",15],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",15],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",15],[10,"decode","","",15],[10,"encode","","",15],[0,"minkowski_sampling","ncollide2df64::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide2df64::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide2df64::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide2df64::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",16],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",16],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",16],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",16],[10,"clone","","",17],[10,"new","","Creates a new `YesSirSurfaceSelector`.",17],[10,"set_max_lmd","","",17],[10,"is_flat","","",17],[10,"may_contain_a_closest_point","","",17],[10,"create_test_data","","",17],[10,"clone","","",18],[10,"new","","Creates a new hyperplane-based surface selector.",18],[10,"set_max_lmd","","",18],[10,"is_flat","","",18],[10,"may_contain_a_closest_point","","",18],[10,"create_test_data","","",18],[10,"clone","","",19],[10,"new","","Creates a new tangent-cone based surface detector.",19],[10,"set_max_lmd","","",19],[10,"is_flat","","",19],[10,"may_contain_a_closest_point","","",19],[10,"create_test_data","","",19],[0,"surface_subdivision_tree","ncollide2df64::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide2df64::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[10,"clone","","",20],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",20],[10,"deref","","",20],[10,"drop","","",20],[10,"new","","Creates a new surface subdivision tree cache.",21],[10,"clear","","Removes everything from this cache.",21],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",21],[10,"new_orphan","","Creates a new tree with no parent nor children.",22],[10,"surface","","The surface contained by this node.",22],[10,"data","","Reference to the data contained by this node.",22],[10,"data_mut","","Mutable reference to the data contained by this node.",22],[10,"timestamp","","The timestamp of this tree node.",22],[10,"set_timestamp","","Sets the timestamp of this tree node.",22],[10,"has_left_child","","Whether or not this node has a left child.",22],[10,"has_right_child","","Whether or not this node has a right child.",22],[10,"right_child","","A copy of this node right child.",22],[10,"left_child","","A copy of this node left child.",22],[10,"right_child_ref","","A reference to this node right child.",22],[10,"left_child_ref","","A reference to this node left child.",22],[10,"set_right_child","","Sets the right child of this node.",22],[10,"set_left_child","","Sets the left child of this node.",22],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",22],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",22],[10,"remove_right_child","","Removes the right child of this node.",22],[10,"remove_left_child","","Removes the left child of this node.",22],[6,"CollisionDetector","ncollide2df64::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",23],[9,"num_colls","","The number of collision detected during the last update.",23],[9,"colls","","Collects the collisions detected during the last update.",23],[9,"toi","","Computes the time of impact of two objects.",23],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",24],[9,"num_colls","","The number of collision detected during the last update.",24],[9,"colls","","Collects the collisions detected during the last update.",24],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",25],[0,"broad","ncollide2df64","Broad phases."],[1,"NoIdDispatcher","ncollide2df64::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",26],[9,"remove","","Removes an element from this broad phase.",26],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",26],[9,"update_object","","Updates the collision pairs involving one specific object.",26],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",27],[9,"deactivate","","Marks and object as inactive.",27],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",27],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",27],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",28],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",29],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",30],[9,"is_valid","","Tells whether a collision between two bodies can occur.",30],[0,"volumetric","ncollide2df64","Volume and inertia tensor computation."],[3,"ball_volume","ncollide2df64::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide2df64::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",31],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",31],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",31],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inertia tensor."],[9,"surface","","Computes the surface of this object.",32],[9,"volume","","Computes the volume of this object.",32],[9,"center_of_mass","","Computes the center of mass of this object.",32],[9,"unit_angular_inertia","","Computes the angular inertia tensor of this object.",32],[10,"mass","","Given its density, this computes the mass of this object.",32],[10,"angular_inertia","","Given its mass, this computes the angular inertia of this object.",32],[10,"mass_properties","","Given its density, this computes the mass, center of mass, and inertia tensor of this object.",32],[0,"implicit","ncollide2df64","Definition of support functions."],[3,"cso_support_point","ncollide2df64::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[3,"point_cloud_support_point","","Computes the support point of a cloud of points."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",33],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",33],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",34],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",35],[0,"parametric","ncollide2df64","Definition of parametric surfaces."],[6,"ParametricSurface","ncollide2df64::parametric","Trait implemented by differentiable parametric surfaces."],[9,"at","","Evaluates the parametric surface.",36],[9,"at_u","","Evaluates the surface derivative wrt. `u`.",36],[9,"at_v","","Evaluates the surface derivative wrt. `v`.",36],[9,"at_uu","","Evaluates the surface second derivative wrt. `u`.",36],[9,"at_vv","","Evaluates the surface second derivative wrt. `v`.",36],[9,"at_uv","","Evaluates the surface second derivative wrt. `u` and `v`.",36],[10,"at_u_v","","Evaluates the parametric surface and its first derivatives.",36],[10,"at_u_v_uu_vv_uv","","Evaluates the parametric surface and its first and second derivatides.",36],[9,"at_uv_nk","","Evaluates the parametric surface and its derivative wrt. `u` `n` times and wrt. `v` `k` times.",36],[10,"at_uv_nk_all","","Evaluates all the partial derivatives of the surface, up to the `n`-th derivative.",36],[0,"partitioning","ncollide2df64","Spatial partitioning tools."],[1,"DBVT","ncollide2df64::partitioning","A Dynamic Bounding Volume Tree."],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",37],[11,"center","","The center of this node bounding volume.",37],[11,"object","","An user-defined object.",37],[11,"parent","","This node parent.",37],[1,"BVT","","A Boundig Volume Tree."],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",38],[12,"LeftChildOf","","This leaf is the left child of another node.",38],[12,"Detached","","This leaf is detached from any tree.",38],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",39],[12,"Parts","","Result of the partitioning of several elements.",39],[2,"BVTNode","","A node of the bounding volume tree."],[12,"Internal","","An internal node.",40],[12,"Leaf","","A leaf.",40],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[3,"kdtree_partitioner_with_centers","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",41],[9,"visit_leaf","","Visits a leaf.",41],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",41],[10,"visit_leaf_mut","","Visits a leaf.",41],[6,"BVTTVisitor","","Visitor for the Bounding Volume Traversal Tree."],[9,"visit_internal_internal","","Visit two internal nodes.",42],[9,"visit_leaf_leaf","","Visit two leaves.",42],[9,"visit_internal_leaf","","Visit one internal node and one leaf.",42],[9,"visit_leaf_internal","","Visit one leaf and on internal node.",42],[0,"procedural","ncollide2df64","Procedural mesh generation."],[1,"TriMesh","ncollide2df64::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",43],[11,"normals","","Coordinates of the mesh normals.",43],[11,"uvs","","Textures coordinates of the mesh.",43],[11,"indices","","Index buffer of the mesh.",43],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",44],[11,"normals","","Coordinates of the polyline normals.",44],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",45],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",45],[3,"parametric_surface_uniform","","Not yet implemented in dimensions other than 3."],[3,"parametric_surface_uniform_with_distance_error","","Uniformly triangulates the parametric space."],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[3,"convex_hull3d","","Computes the convex hull of a set of 3d points."],[3,"convex_hull2d","","Computes the convex hull of a set of 2d points."],[3,"convex_hull2d_idx","","Computes the convex hull of a set of 2d points and returns only the indices of the hull\nvertices."],[3,"hacd","","Approximate convex decomposition of a polyline."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide2df64::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[3,"split_index_buffer_and_recover_topology","","Duplicates the indices of each triangle on the given index buffer, giving the same id to each\nidentical vertex."],[0,"path","ncollide2df64::procedural","Path generation."],[1,"PolylinePattern","ncollide2df64::procedural::path","A pattern composed of polyline and two caps."],[1,"PolylinePath","","A path with its sample points given by a polyline."],[1,"ArrowheadCap","","A cap that looks like an arrow."],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",46],[12,"InnerPoint","","A point that is inside of the path currently generated.",46],[12,"EndPoint","","A point that ends the path currently generated.",46],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",46],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",47],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",48],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",49],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",49],[6,"ToTriMesh","ncollide2df64::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",50],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",51],[0,"utils","ncollide2df64","Miscelaneous, unsorted generic geometric utilities."],[1,"BacktrackingLineSearch","ncollide2df64::utils","The backtracking line search method."],[1,"HashablePartialEq","","A structure that implements `Eq` and is hashable even if the wrapped data implements only\n`PartialEq`."],[3,"center","","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[3,"is_affinely_dependent_triangle","","Tests if three points are exactly aligned."],[3,"is_point_in_triangle","","Tests if a point is inside of a triangle."],[3,"triangle_area","","Computes the area of a triangle."],[3,"triangle_perimeter","","Computes the perimeter of a triangle."],[3,"tetrahedron_volume","","Computes the volume of a tetrahedron."],[3,"tetrahedron_signed_volume","","Computes the signed volume of a tetrahedron."],[3,"tetrahedron_center","","Computes the center of a tetrahedron."],[3,"remove_unused_points","","Given an index buffer, remove from `points` every point that is not indexed."],[3,"dcos","","Computes the n-th derivative of the cosinus function."],[3,"dsin","","Computes the n-th derivative of the sinus function."],[3,"binom","","Computes the binomial coefficient C^k_n (\"k among n\")."],[3,"maximize_with_newton","","Maximizes a real function using the Newton method."],[3,"newton","","Finds the root of a function using the Newton method."],[3,"minimize_with_bfgs","","Minimizes a function using the bfgs method."],[3,"bfgs","","Minimizes a function using the quasi-newton BFGS method."],[3,"cov","","Computes the convariance matrix of a set of points."],[3,"cov_and_center","","Computes the covariance matrix and center of a set of points."],[3,"center_reduce","","Centers and reduces a set of data."],[3,"sort3","","Sorts a set of three values in increasing order."],[0,"symbolic","","Basic symbolic computation system."],[1,"Deriv","ncollide2df64::utils::symbolic","The derivative of `A`."],[1,"DerivU","","The derivative of `A` wrt. `u`."],[1,"DerivV","","The derivative of `A` wrt. `v`."],[1,"SymComp","","The composition operator."],[1,"SymMult","","The multiplication operator."],[1,"SymAdd","","The addition operator."],[1,"SymSub","","The subtraction operator."],[1,"SymNeg","","The negation operator."],[1,"T","","A univariate function of `T`."],[1,"U","","A bivariate function of `U`."],[1,"V","","A bivariate function of `V`."],[1,"Sin","","The sinus function."],[1,"Cos","","The cosinus function."],[1,"Exp","","The exponential function."],[1,"Poly1","","A polynomial function."],[1,"Poly2","","A polynomial function."],[1,"Poly3","","A polynomial function."],[1,"Poly4","","A polynomial function."],[1,"Poly5","","A polynomial function."],[1,"Poly6","","A polynomial function."],[3,"deriv","","The derivative of `A`."],[3,"deriv_u","","The derivative of `A` wrt. `u`."],[3,"deriv_v","","The derivative of `A` wrt. `v`."],[3,"comp","","Symbolic representation of the composition of two functions."],[3,"mult","","Symbolic representation of the multiplication of two functions."],[3,"add","","Symbolic representation of the addition of two functions."],[3,"sub","","Symbolic representation of the subtraction of two functions."],[3,"neg","","Symbolic representation of the negation of a function."],[3,"t","","A univariate function of `t`."],[3,"u","","A bivariate function of `u`."],[3,"v","","A bivariate function of `v`."],[3,"sin","","The sinus function."],[3,"cos","","The cosinus function."],[3,"exp","","The exponential function."],[3,"t1","","A polynomial function."],[3,"t2","","A polynomial function."],[3,"t3","","A polynomial function."],[3,"t4","","A polynomial function."],[3,"t5","","A polynomial function."],[3,"t6","","A polynomial function."],[6,"UnivariateFn","","Trait implemented by smooth univariate functions."],[9,"d0","","Evaluates the function.",52],[10,"ueval","","Same as `d0`.",52],[9,"d1","","Evaluates the first derivative.",52],[9,"d2","","Evaluates the second derivative.",52],[9,"dn","","Evaluates the n-th derivative.",52],[10,"d0_1","","Evaluates the function and its first derivative.",52],[10,"d0_1_2","","Evaluates the function and its first two derivatives.",52],[10,"dn_all","","Evaluates the function and all its derivative, up to the n-th (included).",52],[6,"BivariateFn","","Trait implemented by smooth bivariate functions."],[9,"d0","","Evaluates the function.",53],[10,"beval","","Same as `d0`.",53],[9,"du","","Evaluates the first derivative wrt. `u`.",53],[9,"dv","","Evaluates the firt derivative wrt. `v`.",53],[9,"duu","","Evaluates the second derivative wrt. `u`.",53],[9,"dvv","","Evaluates the second derivative wrt. `v`.",53],[9,"duv","","Evaluates the second derivative wrt. `u` and `v`.",53],[9,"duv_nk","","Evaluate the n-th derivative wrt. `u` and k-th derivative wrt. `v`.",53],[10,"duv_nk_all","","Evaluate all the n-th derivative wrt. `u` and k-th derivative wrt. `v`.",53],[6,"LineSearch","ncollide2df64::utils","Trait for line search methods."],[9,"step_size","","Gets a near-optimal step size for the next descent.",54],[6,"AnyPrivate","",""],[9,"get_dyn_type_id","","The type id of `Self`.",55],[6,"AsBytes","","Trait that transforms thing to a slice of u8."],[9,"as_bytes","","",56],[0,"data","ncollide2df64","Data structure utilities."],[0,"pair","ncollide2df64::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide2df64::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",57],[11,"second","","second object of the pair",57],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[10,"decode","","",57],[10,"encode","","",57],[10,"clone","","",57],[10,"new","","Builds a new `Pair`.",57],[10,"eq","","",57],[10,"decode","","",58],[10,"encode","","",58],[10,"new","","Creates a new PairTWHash",58],[10,"hash","","",58],[0,"hash","ncollide2df64::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide2df64::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[1,"UintTWHash","","Hash function for `uint`."],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",59],[10,"decode","","",60],[10,"encode","","",60],[10,"clone","","",60],[10,"new","","Creates a new UintPairTWHash.",60],[10,"hash","","",60],[10,"decode","","",61],[10,"encode","","",61],[10,"clone","","",61],[10,"new","","Creates a new UintTWHash.",61],[10,"hash","","",61],[0,"hash_map","ncollide2df64::data","An hash map with a customizable hash function."],[1,"Entry","ncollide2df64::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",62],[11,"value","","The value of the entry.",62],[1,"HashMap","","Alternative implementation of `HashMap`."],[10,"decode","","",62],[10,"encode","","",62],[10,"clone","","",62],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"new","","Creates a new hash map.",63],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",63],[10,"elements","","The elements added to this hash map.",63],[10,"elements_mut","","The elements added to this hash map.",63],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",63],[10,"get_and_remove","","Removes an element and returns its value if it existed.",63],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",63],[10,"insert_or_replace","","Inserts or replace an element.",63],[10,"len","","",63],[10,"clear","","",63],[10,"contains_key","","",63],[10,"find","","",63],[10,"insert","","Inserts an element on the hash map.",63],[10,"remove","","Remove an element from the hash map.",63],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",63],[0,"owned_allocation_cache","ncollide2df64::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide2df64::data::owned_allocation_cache","Cache for owned objects."],[10,"new","","Initializes the cache.",64],[10,"alloc","","Box a value into a potentially already allocated box.",64],[10,"retain","","Retains a box which can be re-used by the `box` method.",64],[10,"clear","","Clears the cache, destroying any stored pointer.",64],[0,"has_uid","ncollide2df64::data","Objects with an unique identifier."],[6,"HasUid","ncollide2df64::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",65],[10,"uid","std::gc","",66],[10,"uid","alloc::rc","",67],[10,"uid","alloc::arc","",68],[0,"vec_slice","ncollide2df64::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide2df64::data::vec_slice","A vector slice with a specific length and stride."],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[10,"len","","",69],[10,"is_empty","","",69],[10,"len","","",70],[10,"is_empty","","",70],[10,"new","","Creates a new immutable slice.",69],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",69],[10,"get","","Gets the i-th element of the slice.",69],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",69],[10,"new","","Creates a new mutable slice.",70],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",70],[10,"as_slice","","Creates an immutable slice from this mutable slice.",70],[10,"get","","Gets the i-th element of the slice.",70],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",70],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",70],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",70],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",70],[0,"math","ncollide2df64","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide2df64::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",71],[10,"to_world_space","","",71],[10,"to_relative_wrt_point","","",71]],"paths":[[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[6,"ParametricSurface"],[1,"DBVTLeaf"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[2,"BVTNode"],[6,"BVTVisitor"],[6,"BVTTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[6,"UnivariateFn"],[6,"BivariateFn"],[6,"LineSearch"],[6,"AnyPrivate"],[6,"AsBytes"],[1,"Pair"],[1,"PairTWHash"],[6,"HashFun"],[1,"UintPairTWHash"],[1,"UintTWHash"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};

searchIndex['ncollide2df32'] = {"items":[[0,"","ncollide2df32","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide2df32::bounding_volume","An Axis Aligned Bounding Box."],[1,"BoundingSphere","","A Bounding Sphere."],[1,"SpacializedCone","","A normal cone with a bounding sphere."],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",0],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",1],[9,"contains","","Checks if this bounding volume contains another one.",1],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",1],[9,"merged","","Merges this bounding volume with another one.",1],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",2],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",2],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",3],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",4],[0,"geom","ncollide2df32","Geometric primitives."],[1,"Ball","ncollide2df32::geom","A Ball geometry."],[1,"Plane","","Implicit description of a plane."],[1,"Cuboid","","Geometry of a box."],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[1,"Convex","","Set of point assumed to form a convex polyline."],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[1,"Compound","","A compound geometry with an aabb bounding volume."],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[1,"Segment","","A segment geometry."],[1,"Triangle","","A triangle geometry."],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[1,"Torus","","A torus."],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",5],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",5],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",6],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",7],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",7],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",7],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",7],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",7],[0,"ray","ncollide2df32","Ray casting utilities."],[1,"Ray","ncollide2df32::ray","A Ray."],[11,"orig","","Starting point of the ray.",8],[11,"dir","","Direction of the ray.",8],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",9],[11,"normal","","The normal at the intersection point.",9],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",9],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[3,"triangle_ray_intersection","","Not yet implemented in dimensions other than 3."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",10],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",10],[10,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this geometry and a ray.",10],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",10],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",10],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",10],[10,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\ngeometry and a ray.",10],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",10],[0,"narrow","ncollide2df32","Narrow phases."],[1,"Contact","ncollide2df32::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",11],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",11],[11,"normal","","Contact normal",11],[11,"depth","","Penetration depth",11],[1,"Empty","","A collision detector that does nothing."],[1,"BallBall","","Collision detector between two balls."],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"ball_ball","ncollide2df32::narrow::toi","Computes the Time Of Impact of two balls."],[3,"plane_implicit","","Computes the Time Of Impact of a geometry and a plane."],[3,"implicit_implicit","","Computes the Time Of Impact of two geometries."],[3,"implicit_implicit_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide2df32::narrow","Functions to compute one contact point between two geometries."],[3,"ball_ball","ncollide2df32::narrow::collide","Computes the contact point between two balls."],[3,"plane_implicit","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"implicit_implicit","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide2df32::narrow","Functions to compute the closest points between two geometries."],[3,"ball_ball","ncollide2df32::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide2df32::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide2df32::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide2df32::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",12],[9,"translate_by","","Translates each point of this simplex.",12],[9,"add_point","","Adds a point to the simplex.",12],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",12],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",12],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",12],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",12],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",12],[0,"johnson_simplex","ncollide2df32::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide2df32::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[10,"clone","","",13],[10,"decode","","",14],[10,"encode","","",14],[10,"clone","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",14],[10,"new","","Creates a new, empty, Johnson simplex.",13],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",13],[10,"reset","","",13],[10,"dimension","","",13],[10,"max_sq_len","","",13],[10,"contains_point","","",13],[10,"add_point","","",13],[10,"project_origin_and_reduce","","",13],[10,"project_origin","","",13],[10,"translate_by","","",13],[0,"gjk","ncollide2df32::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide2df32::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",15],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",15],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",15],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",15],[10,"decode","","",15],[10,"encode","","",15],[0,"minkowski_sampling","ncollide2df32::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide2df32::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide2df32::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide2df32::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",16],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",16],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",16],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",16],[10,"clone","","",17],[10,"new","","Creates a new `YesSirSurfaceSelector`.",17],[10,"set_max_lmd","","",17],[10,"is_flat","","",17],[10,"may_contain_a_closest_point","","",17],[10,"create_test_data","","",17],[10,"clone","","",18],[10,"new","","Creates a new hyperplane-based surface selector.",18],[10,"set_max_lmd","","",18],[10,"is_flat","","",18],[10,"may_contain_a_closest_point","","",18],[10,"create_test_data","","",18],[10,"clone","","",19],[10,"new","","Creates a new tangent-cone based surface detector.",19],[10,"set_max_lmd","","",19],[10,"is_flat","","",19],[10,"may_contain_a_closest_point","","",19],[10,"create_test_data","","",19],[0,"surface_subdivision_tree","ncollide2df32::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide2df32::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[10,"clone","","",20],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",20],[10,"deref","","",20],[10,"drop","","",20],[10,"new","","Creates a new surface subdivision tree cache.",21],[10,"clear","","Removes everything from this cache.",21],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",21],[10,"new_orphan","","Creates a new tree with no parent nor children.",22],[10,"surface","","The surface contained by this node.",22],[10,"data","","Reference to the data contained by this node.",22],[10,"data_mut","","Mutable reference to the data contained by this node.",22],[10,"timestamp","","The timestamp of this tree node.",22],[10,"set_timestamp","","Sets the timestamp of this tree node.",22],[10,"has_left_child","","Whether or not this node has a left child.",22],[10,"has_right_child","","Whether or not this node has a right child.",22],[10,"right_child","","A copy of this node right child.",22],[10,"left_child","","A copy of this node left child.",22],[10,"right_child_ref","","A reference to this node right child.",22],[10,"left_child_ref","","A reference to this node left child.",22],[10,"set_right_child","","Sets the right child of this node.",22],[10,"set_left_child","","Sets the left child of this node.",22],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",22],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",22],[10,"remove_right_child","","Removes the right child of this node.",22],[10,"remove_left_child","","Removes the left child of this node.",22],[6,"CollisionDetector","ncollide2df32::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",23],[9,"num_colls","","The number of collision detected during the last update.",23],[9,"colls","","Collects the collisions detected during the last update.",23],[9,"toi","","Computes the time of impact of two objects.",23],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",24],[9,"num_colls","","The number of collision detected during the last update.",24],[9,"colls","","Collects the collisions detected during the last update.",24],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",25],[0,"broad","ncollide2df32","Broad phases."],[1,"NoIdDispatcher","ncollide2df32::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",26],[9,"remove","","Removes an element from this broad phase.",26],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",26],[9,"update_object","","Updates the collision pairs involving one specific object.",26],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",27],[9,"deactivate","","Marks and object as inactive.",27],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",27],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",27],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",28],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",29],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",30],[9,"is_valid","","Tells whether a collision between two bodies can occur.",30],[0,"volumetric","ncollide2df32","Volume and inertia tensor computation."],[3,"ball_volume","ncollide2df32::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide2df32::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",31],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",31],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",31],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inertia tensor."],[9,"surface","","Computes the surface of this object.",32],[9,"volume","","Computes the volume of this object.",32],[9,"center_of_mass","","Computes the center of mass of this object.",32],[9,"unit_angular_inertia","","Computes the angular inertia tensor of this object.",32],[10,"mass","","Given its density, this computes the mass of this object.",32],[10,"angular_inertia","","Given its mass, this computes the angular inertia of this object.",32],[10,"mass_properties","","Given its density, this computes the mass, center of mass, and inertia tensor of this object.",32],[0,"implicit","ncollide2df32","Definition of support functions."],[3,"cso_support_point","ncollide2df32::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[3,"point_cloud_support_point","","Computes the support point of a cloud of points."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",33],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",33],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",34],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",35],[0,"parametric","ncollide2df32","Definition of parametric surfaces."],[6,"ParametricSurface","ncollide2df32::parametric","Trait implemented by differentiable parametric surfaces."],[9,"at","","Evaluates the parametric surface.",36],[9,"at_u","","Evaluates the surface derivative wrt. `u`.",36],[9,"at_v","","Evaluates the surface derivative wrt. `v`.",36],[9,"at_uu","","Evaluates the surface second derivative wrt. `u`.",36],[9,"at_vv","","Evaluates the surface second derivative wrt. `v`.",36],[9,"at_uv","","Evaluates the surface second derivative wrt. `u` and `v`.",36],[10,"at_u_v","","Evaluates the parametric surface and its first derivatives.",36],[10,"at_u_v_uu_vv_uv","","Evaluates the parametric surface and its first and second derivatides.",36],[9,"at_uv_nk","","Evaluates the parametric surface and its derivative wrt. `u` `n` times and wrt. `v` `k` times.",36],[10,"at_uv_nk_all","","Evaluates all the partial derivatives of the surface, up to the `n`-th derivative.",36],[0,"partitioning","ncollide2df32","Spatial partitioning tools."],[1,"DBVT","ncollide2df32::partitioning","A Dynamic Bounding Volume Tree."],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",37],[11,"center","","The center of this node bounding volume.",37],[11,"object","","An user-defined object.",37],[11,"parent","","This node parent.",37],[1,"BVT","","A Boundig Volume Tree."],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",38],[12,"LeftChildOf","","This leaf is the left child of another node.",38],[12,"Detached","","This leaf is detached from any tree.",38],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",39],[12,"Parts","","Result of the partitioning of several elements.",39],[2,"BVTNode","","A node of the bounding volume tree."],[12,"Internal","","An internal node.",40],[12,"Leaf","","A leaf.",40],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[3,"kdtree_partitioner_with_centers","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",41],[9,"visit_leaf","","Visits a leaf.",41],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",41],[10,"visit_leaf_mut","","Visits a leaf.",41],[6,"BVTTVisitor","","Visitor for the Bounding Volume Traversal Tree."],[9,"visit_internal_internal","","Visit two internal nodes.",42],[9,"visit_leaf_leaf","","Visit two leaves.",42],[9,"visit_internal_leaf","","Visit one internal node and one leaf.",42],[9,"visit_leaf_internal","","Visit one leaf and on internal node.",42],[0,"procedural","ncollide2df32","Procedural mesh generation."],[1,"TriMesh","ncollide2df32::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",43],[11,"normals","","Coordinates of the mesh normals.",43],[11,"uvs","","Textures coordinates of the mesh.",43],[11,"indices","","Index buffer of the mesh.",43],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",44],[11,"normals","","Coordinates of the polyline normals.",44],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",45],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",45],[3,"parametric_surface_uniform","","Not yet implemented in dimensions other than 3."],[3,"parametric_surface_uniform_with_distance_error","","Uniformly triangulates the parametric space."],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[3,"convex_hull3d","","Computes the convex hull of a set of 3d points."],[3,"convex_hull2d","","Computes the convex hull of a set of 2d points."],[3,"convex_hull2d_idx","","Computes the convex hull of a set of 2d points and returns only the indices of the hull\nvertices."],[3,"hacd","","Approximate convex decomposition of a polyline."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide2df32::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[3,"split_index_buffer_and_recover_topology","","Duplicates the indices of each triangle on the given index buffer, giving the same id to each\nidentical vertex."],[0,"path","ncollide2df32::procedural","Path generation."],[1,"PolylinePattern","ncollide2df32::procedural::path","A pattern composed of polyline and two caps."],[1,"PolylinePath","","A path with its sample points given by a polyline."],[1,"ArrowheadCap","","A cap that looks like an arrow."],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",46],[12,"InnerPoint","","A point that is inside of the path currently generated.",46],[12,"EndPoint","","A point that ends the path currently generated.",46],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",46],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",47],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",48],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",49],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",49],[6,"ToTriMesh","ncollide2df32::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",50],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",51],[0,"utils","ncollide2df32","Miscelaneous, unsorted generic geometric utilities."],[1,"BacktrackingLineSearch","ncollide2df32::utils","The backtracking line search method."],[1,"HashablePartialEq","","A structure that implements `Eq` and is hashable even if the wrapped data implements only\n`PartialEq`."],[3,"center","","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[3,"is_affinely_dependent_triangle","","Tests if three points are exactly aligned."],[3,"is_point_in_triangle","","Tests if a point is inside of a triangle."],[3,"triangle_area","","Computes the area of a triangle."],[3,"triangle_perimeter","","Computes the perimeter of a triangle."],[3,"tetrahedron_volume","","Computes the volume of a tetrahedron."],[3,"tetrahedron_signed_volume","","Computes the signed volume of a tetrahedron."],[3,"tetrahedron_center","","Computes the center of a tetrahedron."],[3,"remove_unused_points","","Given an index buffer, remove from `points` every point that is not indexed."],[3,"dcos","","Computes the n-th derivative of the cosinus function."],[3,"dsin","","Computes the n-th derivative of the sinus function."],[3,"binom","","Computes the binomial coefficient C^k_n (\"k among n\")."],[3,"maximize_with_newton","","Maximizes a real function using the Newton method."],[3,"newton","","Finds the root of a function using the Newton method."],[3,"minimize_with_bfgs","","Minimizes a function using the bfgs method."],[3,"bfgs","","Minimizes a function using the quasi-newton BFGS method."],[3,"cov","","Computes the convariance matrix of a set of points."],[3,"cov_and_center","","Computes the covariance matrix and center of a set of points."],[3,"center_reduce","","Centers and reduces a set of data."],[3,"sort3","","Sorts a set of three values in increasing order."],[0,"symbolic","","Basic symbolic computation system."],[1,"Deriv","ncollide2df32::utils::symbolic","The derivative of `A`."],[1,"DerivU","","The derivative of `A` wrt. `u`."],[1,"DerivV","","The derivative of `A` wrt. `v`."],[1,"SymComp","","The composition operator."],[1,"SymMult","","The multiplication operator."],[1,"SymAdd","","The addition operator."],[1,"SymSub","","The subtraction operator."],[1,"SymNeg","","The negation operator."],[1,"T","","A univariate function of `T`."],[1,"U","","A bivariate function of `U`."],[1,"V","","A bivariate function of `V`."],[1,"Sin","","The sinus function."],[1,"Cos","","The cosinus function."],[1,"Exp","","The exponential function."],[1,"Poly1","","A polynomial function."],[1,"Poly2","","A polynomial function."],[1,"Poly3","","A polynomial function."],[1,"Poly4","","A polynomial function."],[1,"Poly5","","A polynomial function."],[1,"Poly6","","A polynomial function."],[3,"deriv","","The derivative of `A`."],[3,"deriv_u","","The derivative of `A` wrt. `u`."],[3,"deriv_v","","The derivative of `A` wrt. `v`."],[3,"comp","","Symbolic representation of the composition of two functions."],[3,"mult","","Symbolic representation of the multiplication of two functions."],[3,"add","","Symbolic representation of the addition of two functions."],[3,"sub","","Symbolic representation of the subtraction of two functions."],[3,"neg","","Symbolic representation of the negation of a function."],[3,"t","","A univariate function of `t`."],[3,"u","","A bivariate function of `u`."],[3,"v","","A bivariate function of `v`."],[3,"sin","","The sinus function."],[3,"cos","","The cosinus function."],[3,"exp","","The exponential function."],[3,"t1","","A polynomial function."],[3,"t2","","A polynomial function."],[3,"t3","","A polynomial function."],[3,"t4","","A polynomial function."],[3,"t5","","A polynomial function."],[3,"t6","","A polynomial function."],[6,"UnivariateFn","","Trait implemented by smooth univariate functions."],[9,"d0","","Evaluates the function.",52],[10,"ueval","","Same as `d0`.",52],[9,"d1","","Evaluates the first derivative.",52],[9,"d2","","Evaluates the second derivative.",52],[9,"dn","","Evaluates the n-th derivative.",52],[10,"d0_1","","Evaluates the function and its first derivative.",52],[10,"d0_1_2","","Evaluates the function and its first two derivatives.",52],[10,"dn_all","","Evaluates the function and all its derivative, up to the n-th (included).",52],[6,"BivariateFn","","Trait implemented by smooth bivariate functions."],[9,"d0","","Evaluates the function.",53],[10,"beval","","Same as `d0`.",53],[9,"du","","Evaluates the first derivative wrt. `u`.",53],[9,"dv","","Evaluates the firt derivative wrt. `v`.",53],[9,"duu","","Evaluates the second derivative wrt. `u`.",53],[9,"dvv","","Evaluates the second derivative wrt. `v`.",53],[9,"duv","","Evaluates the second derivative wrt. `u` and `v`.",53],[9,"duv_nk","","Evaluate the n-th derivative wrt. `u` and k-th derivative wrt. `v`.",53],[10,"duv_nk_all","","Evaluate all the n-th derivative wrt. `u` and k-th derivative wrt. `v`.",53],[6,"LineSearch","ncollide2df32::utils","Trait for line search methods."],[9,"step_size","","Gets a near-optimal step size for the next descent.",54],[6,"AnyPrivate","",""],[9,"get_dyn_type_id","","The type id of `Self`.",55],[6,"AsBytes","","Trait that transforms thing to a slice of u8."],[9,"as_bytes","","",56],[0,"data","ncollide2df32","Data structure utilities."],[0,"pair","ncollide2df32::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide2df32::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",57],[11,"second","","second object of the pair",57],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[10,"decode","","",57],[10,"encode","","",57],[10,"clone","","",57],[10,"new","","Builds a new `Pair`.",57],[10,"eq","","",57],[10,"decode","","",58],[10,"encode","","",58],[10,"new","","Creates a new PairTWHash",58],[10,"hash","","",58],[0,"hash","ncollide2df32::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide2df32::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[1,"UintTWHash","","Hash function for `uint`."],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",59],[10,"decode","","",60],[10,"encode","","",60],[10,"clone","","",60],[10,"new","","Creates a new UintPairTWHash.",60],[10,"hash","","",60],[10,"decode","","",61],[10,"encode","","",61],[10,"clone","","",61],[10,"new","","Creates a new UintTWHash.",61],[10,"hash","","",61],[0,"hash_map","ncollide2df32::data","An hash map with a customizable hash function."],[1,"Entry","ncollide2df32::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",62],[11,"value","","The value of the entry.",62],[1,"HashMap","","Alternative implementation of `HashMap`."],[10,"decode","","",62],[10,"encode","","",62],[10,"clone","","",62],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"new","","Creates a new hash map.",63],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",63],[10,"elements","","The elements added to this hash map.",63],[10,"elements_mut","","The elements added to this hash map.",63],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",63],[10,"get_and_remove","","Removes an element and returns its value if it existed.",63],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",63],[10,"insert_or_replace","","Inserts or replace an element.",63],[10,"len","","",63],[10,"clear","","",63],[10,"contains_key","","",63],[10,"find","","",63],[10,"insert","","Inserts an element on the hash map.",63],[10,"remove","","Remove an element from the hash map.",63],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",63],[0,"owned_allocation_cache","ncollide2df32::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide2df32::data::owned_allocation_cache","Cache for owned objects."],[10,"new","","Initializes the cache.",64],[10,"alloc","","Box a value into a potentially already allocated box.",64],[10,"retain","","Retains a box which can be re-used by the `box` method.",64],[10,"clear","","Clears the cache, destroying any stored pointer.",64],[0,"has_uid","ncollide2df32::data","Objects with an unique identifier."],[6,"HasUid","ncollide2df32::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",65],[10,"uid","std::gc","",66],[10,"uid","alloc::rc","",67],[10,"uid","alloc::arc","",68],[0,"vec_slice","ncollide2df32::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide2df32::data::vec_slice","A vector slice with a specific length and stride."],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[10,"len","","",69],[10,"is_empty","","",69],[10,"len","","",70],[10,"is_empty","","",70],[10,"new","","Creates a new immutable slice.",69],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",69],[10,"get","","Gets the i-th element of the slice.",69],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",69],[10,"new","","Creates a new mutable slice.",70],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",70],[10,"as_slice","","Creates an immutable slice from this mutable slice.",70],[10,"get","","Gets the i-th element of the slice.",70],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",70],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",70],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",70],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",70],[0,"math","ncollide2df32","Compilation-flags-dependent aliases for mathematical types."],[4,"Scalar","ncollide2df32::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",71],[10,"to_world_space","","",71],[10,"to_relative_wrt_point","","",71]],"paths":[[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[6,"ParametricSurface"],[1,"DBVTLeaf"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[2,"BVTNode"],[6,"BVTVisitor"],[6,"BVTTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[6,"UnivariateFn"],[6,"BivariateFn"],[6,"LineSearch"],[6,"AnyPrivate"],[6,"AsBytes"],[1,"Pair"],[1,"PairTWHash"],[6,"HashFun"],[1,"UintPairTWHash"],[1,"UintTWHash"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};

searchIndex['ncollide3df64'] = {"items":[[0,"","ncollide3df64","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide3df64::bounding_volume","An Axis Aligned Bounding Box."],[1,"BoundingSphere","","A Bounding Sphere."],[1,"SpacializedCone","","A normal cone with a bounding sphere."],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",0],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",1],[9,"contains","","Checks if this bounding volume contains another one.",1],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",1],[9,"merged","","Merges this bounding volume with another one.",1],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",2],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",2],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",3],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",4],[0,"geom","ncollide3df64","Geometric primitives."],[1,"Ball","ncollide3df64::geom","A Ball geometry."],[1,"Plane","","Implicit description of a plane."],[1,"Cuboid","","Geometry of a box."],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[1,"Convex","","Set of point assumed to form a convex polytope."],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[1,"Compound","","A compound geometry with an aabb bounding volume."],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[1,"Segment","","A segment geometry."],[1,"Triangle","","A triangle geometry."],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[1,"Torus","","A torus."],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",5],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",5],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",6],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",7],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",7],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",7],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",7],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",7],[0,"ray","ncollide3df64","Ray casting utilities."],[1,"Ray","ncollide3df64::ray","A Ray."],[11,"orig","","Starting point of the ray.",8],[11,"dir","","Direction of the ray.",8],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",9],[11,"normal","","The normal at the intersection point.",9],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",9],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[3,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",10],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",10],[10,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this geometry and a ray.",10],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",10],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",10],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",10],[10,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\ngeometry and a ray.",10],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",10],[0,"narrow","ncollide3df64","Narrow phases."],[1,"Contact","ncollide3df64::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",11],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",11],[11,"normal","","Contact normal",11],[11,"depth","","Penetration depth",11],[1,"Empty","","A collision detector that does nothing."],[1,"BallBall","","Collision detector between two balls."],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"ball_ball","ncollide3df64::narrow::toi","Computes the Time Of Impact of two balls."],[3,"plane_implicit","","Computes the Time Of Impact of a geometry and a plane."],[3,"implicit_implicit","","Computes the Time Of Impact of two geometries."],[3,"implicit_implicit_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide3df64::narrow","Functions to compute one contact point between two geometries."],[3,"ball_ball","ncollide3df64::narrow::collide","Computes the contact point between two balls."],[3,"plane_implicit","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"implicit_implicit","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide3df64::narrow","Functions to compute the closest points between two geometries."],[3,"ball_ball","ncollide3df64::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide3df64::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide3df64::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide3df64::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",12],[9,"translate_by","","Translates each point of this simplex.",12],[9,"add_point","","Adds a point to the simplex.",12],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",12],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",12],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",12],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",12],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",12],[0,"johnson_simplex","ncollide3df64::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide3df64::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[10,"clone","","",13],[10,"decode","","",14],[10,"encode","","",14],[10,"clone","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",14],[10,"new","","Creates a new, empty, Johnson simplex.",13],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",13],[10,"reset","","",13],[10,"dimension","","",13],[10,"max_sq_len","","",13],[10,"contains_point","","",13],[10,"add_point","","",13],[10,"project_origin_and_reduce","","",13],[10,"project_origin","","",13],[10,"translate_by","","",13],[0,"gjk","ncollide3df64::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide3df64::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",15],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",15],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",15],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",15],[10,"decode","","",15],[10,"encode","","",15],[0,"minkowski_sampling","ncollide3df64::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide3df64::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide3df64::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide3df64::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",16],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",16],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",16],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",16],[10,"clone","","",17],[10,"new","","Creates a new `YesSirSurfaceSelector`.",17],[10,"set_max_lmd","","",17],[10,"is_flat","","",17],[10,"may_contain_a_closest_point","","",17],[10,"create_test_data","","",17],[10,"clone","","",18],[10,"new","","Creates a new hyperplane-based surface selector.",18],[10,"set_max_lmd","","",18],[10,"is_flat","","",18],[10,"may_contain_a_closest_point","","",18],[10,"create_test_data","","",18],[10,"clone","","",19],[10,"new","","Creates a new tangent-cone based surface detector.",19],[10,"set_max_lmd","","",19],[10,"is_flat","","",19],[10,"may_contain_a_closest_point","","",19],[10,"create_test_data","","",19],[0,"surface_subdivision_tree","ncollide3df64::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide3df64::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[10,"clone","","",20],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",20],[10,"deref","","",20],[10,"drop","","",20],[10,"new","","Creates a new surface subdivision tree cache.",21],[10,"clear","","Removes everything from this cache.",21],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",21],[10,"new_orphan","","Creates a new tree with no parent nor children.",22],[10,"surface","","The surface contained by this node.",22],[10,"data","","Reference to the data contained by this node.",22],[10,"data_mut","","Mutable reference to the data contained by this node.",22],[10,"timestamp","","The timestamp of this tree node.",22],[10,"set_timestamp","","Sets the timestamp of this tree node.",22],[10,"has_left_child","","Whether or not this node has a left child.",22],[10,"has_right_child","","Whether or not this node has a right child.",22],[10,"right_child","","A copy of this node right child.",22],[10,"left_child","","A copy of this node left child.",22],[10,"right_child_ref","","A reference to this node right child.",22],[10,"left_child_ref","","A reference to this node left child.",22],[10,"set_right_child","","Sets the right child of this node.",22],[10,"set_left_child","","Sets the left child of this node.",22],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",22],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",22],[10,"remove_right_child","","Removes the right child of this node.",22],[10,"remove_left_child","","Removes the left child of this node.",22],[6,"CollisionDetector","ncollide3df64::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",23],[9,"num_colls","","The number of collision detected during the last update.",23],[9,"colls","","Collects the collisions detected during the last update.",23],[9,"toi","","Computes the time of impact of two objects.",23],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",24],[9,"num_colls","","The number of collision detected during the last update.",24],[9,"colls","","Collects the collisions detected during the last update.",24],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",25],[0,"broad","ncollide3df64","Broad phases."],[1,"NoIdDispatcher","ncollide3df64::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",26],[9,"remove","","Removes an element from this broad phase.",26],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",26],[9,"update_object","","Updates the collision pairs involving one specific object.",26],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",27],[9,"deactivate","","Marks and object as inactive.",27],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",27],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",27],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",28],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",29],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",30],[9,"is_valid","","Tells whether a collision between two bodies can occur.",30],[0,"volumetric","ncollide3df64","Volume and inertia tensor computation."],[3,"ball_volume","ncollide3df64::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide3df64::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",31],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",31],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",31],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inertia tensor."],[9,"surface","","Computes the surface of this object.",32],[9,"volume","","Computes the volume of this object.",32],[9,"center_of_mass","","Computes the center of mass of this object.",32],[9,"unit_angular_inertia","","Computes the angular inertia tensor of this object.",32],[10,"mass","","Given its density, this computes the mass of this object.",32],[10,"angular_inertia","","Given its mass, this computes the angular inertia of this object.",32],[10,"mass_properties","","Given its density, this computes the mass, center of mass, and inertia tensor of this object.",32],[0,"implicit","ncollide3df64","Definition of support functions."],[3,"cso_support_point","ncollide3df64::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[3,"point_cloud_support_point","","Computes the support point of a cloud of points."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",33],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",33],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",34],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",35],[0,"parametric","ncollide3df64","Definition of parametric surfaces."],[6,"ParametricSurface","ncollide3df64::parametric","Trait implemented by differentiable parametric surfaces."],[9,"at","","Evaluates the parametric surface.",36],[9,"at_u","","Evaluates the surface derivative wrt. `u`.",36],[9,"at_v","","Evaluates the surface derivative wrt. `v`.",36],[9,"at_uu","","Evaluates the surface second derivative wrt. `u`.",36],[9,"at_vv","","Evaluates the surface second derivative wrt. `v`.",36],[9,"at_uv","","Evaluates the surface second derivative wrt. `u` and `v`.",36],[10,"at_u_v","","Evaluates the parametric surface and its first derivatives.",36],[10,"at_u_v_uu_vv_uv","","Evaluates the parametric surface and its first and second derivatides.",36],[9,"at_uv_nk","","Evaluates the parametric surface and its derivative wrt. `u` `n` times and wrt. `v` `k` times.",36],[10,"at_uv_nk_all","","Evaluates all the partial derivatives of the surface, up to the `n`-th derivative.",36],[0,"partitioning","ncollide3df64","Spatial partitioning tools."],[1,"DBVT","ncollide3df64::partitioning","A Dynamic Bounding Volume Tree."],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",37],[11,"center","","The center of this node bounding volume.",37],[11,"object","","An user-defined object.",37],[11,"parent","","This node parent.",37],[1,"BVT","","A Boundig Volume Tree."],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",38],[12,"LeftChildOf","","This leaf is the left child of another node.",38],[12,"Detached","","This leaf is detached from any tree.",38],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",39],[12,"Parts","","Result of the partitioning of several elements.",39],[2,"BVTNode","","A node of the bounding volume tree."],[12,"Internal","","An internal node.",40],[12,"Leaf","","A leaf.",40],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[3,"kdtree_partitioner_with_centers","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",41],[9,"visit_leaf","","Visits a leaf.",41],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",41],[10,"visit_leaf_mut","","Visits a leaf.",41],[6,"BVTTVisitor","","Visitor for the Bounding Volume Traversal Tree."],[9,"visit_internal_internal","","Visit two internal nodes.",42],[9,"visit_leaf_leaf","","Visit two leaves.",42],[9,"visit_internal_leaf","","Visit one internal node and one leaf.",42],[9,"visit_leaf_internal","","Visit one leaf and on internal node.",42],[0,"procedural","ncollide3df64","Procedural mesh generation."],[1,"TriMesh","ncollide3df64::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",43],[11,"normals","","Coordinates of the mesh normals.",43],[11,"uvs","","Textures coordinates of the mesh.",43],[11,"indices","","Index buffer of the mesh.",43],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",44],[11,"normals","","Coordinates of the polyline normals.",44],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",45],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",45],[3,"parametric_surface_uniform","","Meshing algorithm that uniformly triangulates the parametric space."],[3,"parametric_surface_uniform_with_distance_error","","Uniformly triangulates the parametric space."],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[3,"convex_hull3d","","Computes the convex hull of a set of 3d points."],[3,"convex_hull2d","","Computes the convex hull of a set of 2d points."],[3,"convex_hull2d_idx","","Computes the convex hull of a set of 2d points and returns only the indices of the hull\nvertices."],[3,"hacd","","Approximate convex decomposition of a triangle mesh."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide3df64::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[3,"split_index_buffer_and_recover_topology","","Duplicates the indices of each triangle on the given index buffer, giving the same id to each\nidentical vertex."],[0,"path","ncollide3df64::procedural","Path generation."],[1,"PolylinePattern","ncollide3df64::procedural::path","A pattern composed of polyline and two caps."],[1,"PolylinePath","","A path with its sample points given by a polyline."],[1,"ArrowheadCap","","A cap that looks like an arrow."],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",46],[12,"InnerPoint","","A point that is inside of the path currently generated.",46],[12,"EndPoint","","A point that ends the path currently generated.",46],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",46],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",47],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",48],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",49],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",49],[6,"ToTriMesh","ncollide3df64::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",50],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",51],[0,"utils","ncollide3df64","Miscelaneous, unsorted generic geometric utilities."],[1,"BacktrackingLineSearch","ncollide3df64::utils","The backtracking line search method."],[1,"HashablePartialEq","","A structure that implements `Eq` and is hashable even if the wrapped data implements only\n`PartialEq`."],[3,"center","","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[3,"is_affinely_dependent_triangle","","Tests if three points are exactly aligned."],[3,"is_point_in_triangle","","Tests if a point is inside of a triangle."],[3,"triangle_area","","Computes the area of a triangle."],[3,"triangle_perimeter","","Computes the perimeter of a triangle."],[3,"tetrahedron_volume","","Computes the volume of a tetrahedron."],[3,"tetrahedron_signed_volume","","Computes the signed volume of a tetrahedron."],[3,"tetrahedron_center","","Computes the center of a tetrahedron."],[3,"remove_unused_points","","Given an index buffer, remove from `points` every point that is not indexed."],[3,"dcos","","Computes the n-th derivative of the cosinus function."],[3,"dsin","","Computes the n-th derivative of the sinus function."],[3,"binom","","Computes the binomial coefficient C^k_n (\"k among n\")."],[3,"maximize_with_newton","","Maximizes a real function using the Newton method."],[3,"newton","","Finds the root of a function using the Newton method."],[3,"minimize_with_bfgs","","Minimizes a function using the bfgs method."],[3,"bfgs","","Minimizes a function using the quasi-newton BFGS method."],[3,"cov","","Computes the convariance matrix of a set of points."],[3,"cov_and_center","","Computes the covariance matrix and center of a set of points."],[3,"center_reduce","","Centers and reduces a set of data."],[3,"sort3","","Sorts a set of three values in increasing order."],[0,"symbolic","","Basic symbolic computation system."],[1,"Deriv","ncollide3df64::utils::symbolic","The derivative of `A`."],[1,"DerivU","","The derivative of `A` wrt. `u`."],[1,"DerivV","","The derivative of `A` wrt. `v`."],[1,"SymComp","","The composition operator."],[1,"SymMult","","The multiplication operator."],[1,"SymAdd","","The addition operator."],[1,"SymSub","","The subtraction operator."],[1,"SymNeg","","The negation operator."],[1,"T","","A univariate function of `T`."],[1,"U","","A bivariate function of `U`."],[1,"V","","A bivariate function of `V`."],[1,"Sin","","The sinus function."],[1,"Cos","","The cosinus function."],[1,"Exp","","The exponential function."],[1,"Poly1","","A polynomial function."],[1,"Poly2","","A polynomial function."],[1,"Poly3","","A polynomial function."],[1,"Poly4","","A polynomial function."],[1,"Poly5","","A polynomial function."],[1,"Poly6","","A polynomial function."],[3,"deriv","","The derivative of `A`."],[3,"deriv_u","","The derivative of `A` wrt. `u`."],[3,"deriv_v","","The derivative of `A` wrt. `v`."],[3,"comp","","Symbolic representation of the composition of two functions."],[3,"mult","","Symbolic representation of the multiplication of two functions."],[3,"add","","Symbolic representation of the addition of two functions."],[3,"sub","","Symbolic representation of the subtraction of two functions."],[3,"neg","","Symbolic representation of the negation of a function."],[3,"t","","A univariate function of `t`."],[3,"u","","A bivariate function of `u`."],[3,"v","","A bivariate function of `v`."],[3,"sin","","The sinus function."],[3,"cos","","The cosinus function."],[3,"exp","","The exponential function."],[3,"t1","","A polynomial function."],[3,"t2","","A polynomial function."],[3,"t3","","A polynomial function."],[3,"t4","","A polynomial function."],[3,"t5","","A polynomial function."],[3,"t6","","A polynomial function."],[6,"UnivariateFn","","Trait implemented by smooth univariate functions."],[9,"d0","","Evaluates the function.",52],[10,"ueval","","Same as `d0`.",52],[9,"d1","","Evaluates the first derivative.",52],[9,"d2","","Evaluates the second derivative.",52],[9,"dn","","Evaluates the n-th derivative.",52],[10,"d0_1","","Evaluates the function and its first derivative.",52],[10,"d0_1_2","","Evaluates the function and its first two derivatives.",52],[10,"dn_all","","Evaluates the function and all its derivative, up to the n-th (included).",52],[6,"BivariateFn","","Trait implemented by smooth bivariate functions."],[9,"d0","","Evaluates the function.",53],[10,"beval","","Same as `d0`.",53],[9,"du","","Evaluates the first derivative wrt. `u`.",53],[9,"dv","","Evaluates the firt derivative wrt. `v`.",53],[9,"duu","","Evaluates the second derivative wrt. `u`.",53],[9,"dvv","","Evaluates the second derivative wrt. `v`.",53],[9,"duv","","Evaluates the second derivative wrt. `u` and `v`.",53],[9,"duv_nk","","Evaluate the n-th derivative wrt. `u` and k-th derivative wrt. `v`.",53],[10,"duv_nk_all","","Evaluate all the n-th derivative wrt. `u` and k-th derivative wrt. `v`.",53],[6,"LineSearch","ncollide3df64::utils","Trait for line search methods."],[9,"step_size","","Gets a near-optimal step size for the next descent.",54],[6,"AnyPrivate","",""],[9,"get_dyn_type_id","","The type id of `Self`.",55],[6,"AsBytes","","Trait that transforms thing to a slice of u8."],[9,"as_bytes","","",56],[0,"data","ncollide3df64","Data structure utilities."],[0,"pair","ncollide3df64::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide3df64::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",57],[11,"second","","second object of the pair",57],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[10,"decode","","",57],[10,"encode","","",57],[10,"clone","","",57],[10,"new","","Builds a new `Pair`.",57],[10,"eq","","",57],[10,"decode","","",58],[10,"encode","","",58],[10,"new","","Creates a new PairTWHash",58],[10,"hash","","",58],[0,"hash","ncollide3df64::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide3df64::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[1,"UintTWHash","","Hash function for `uint`."],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",59],[10,"decode","","",60],[10,"encode","","",60],[10,"clone","","",60],[10,"new","","Creates a new UintPairTWHash.",60],[10,"hash","","",60],[10,"decode","","",61],[10,"encode","","",61],[10,"clone","","",61],[10,"new","","Creates a new UintTWHash.",61],[10,"hash","","",61],[0,"hash_map","ncollide3df64::data","An hash map with a customizable hash function."],[1,"Entry","ncollide3df64::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",62],[11,"value","","The value of the entry.",62],[1,"HashMap","","Alternative implementation of `HashMap`."],[10,"decode","","",62],[10,"encode","","",62],[10,"clone","","",62],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"new","","Creates a new hash map.",63],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",63],[10,"elements","","The elements added to this hash map.",63],[10,"elements_mut","","The elements added to this hash map.",63],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",63],[10,"get_and_remove","","Removes an element and returns its value if it existed.",63],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",63],[10,"insert_or_replace","","Inserts or replace an element.",63],[10,"len","","",63],[10,"clear","","",63],[10,"contains_key","","",63],[10,"find","","",63],[10,"insert","","Inserts an element on the hash map.",63],[10,"remove","","Remove an element from the hash map.",63],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",63],[0,"owned_allocation_cache","ncollide3df64::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide3df64::data::owned_allocation_cache","Cache for owned objects."],[10,"new","","Initializes the cache.",64],[10,"alloc","","Box a value into a potentially already allocated box.",64],[10,"retain","","Retains a box which can be re-used by the `box` method.",64],[10,"clear","","Clears the cache, destroying any stored pointer.",64],[0,"has_uid","ncollide3df64::data","Objects with an unique identifier."],[6,"HasUid","ncollide3df64::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",65],[10,"uid","std::gc","",66],[10,"uid","alloc::rc","",67],[10,"uid","alloc::arc","",68],[0,"vec_slice","ncollide3df64::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide3df64::data::vec_slice","A vector slice with a specific length and stride."],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[10,"len","","",69],[10,"is_empty","","",69],[10,"len","","",70],[10,"is_empty","","",70],[10,"new","","Creates a new immutable slice.",69],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",69],[10,"get","","Gets the i-th element of the slice.",69],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",69],[10,"new","","Creates a new mutable slice.",70],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",70],[10,"as_slice","","Creates an immutable slice from this mutable slice.",70],[10,"get","","Gets the i-th element of the slice.",70],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",70],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",70],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",70],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",70],[0,"math","ncollide3df64","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide3df64::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",71],[10,"to_world_space","","",71],[10,"to_relative_wrt_point","","",71]],"paths":[[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[6,"ParametricSurface"],[1,"DBVTLeaf"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[2,"BVTNode"],[6,"BVTVisitor"],[6,"BVTTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[6,"UnivariateFn"],[6,"BivariateFn"],[6,"LineSearch"],[6,"AnyPrivate"],[6,"AsBytes"],[1,"Pair"],[1,"PairTWHash"],[6,"HashFun"],[1,"UintPairTWHash"],[1,"UintTWHash"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};

searchIndex['nalgebra'] = {"items":[[0,"","nalgebra","# nalgebra"],[0,"na","","**nalgebra** prelude."],[1,"Identity","nalgebra::na","Special identity matrix. All its operation are no-ops."],[1,"DMat","","Matrix with dimensions unknown at compile-time."],[1,"DVec","","Heap allocated, dynamically sized vector."],[11,"at","","Components of the vector. Contains as much elements as the vector dimension.",0],[1,"DVec1","","Stack-allocated, dynamically sized vector with a maximum size of 1."],[1,"DVec2","","Stack-allocated, dynamically sized vector with a maximum size of 2."],[1,"DVec3","","Stack-allocated, dynamically sized vector with a maximum size of 3."],[1,"DVec4","","Stack-allocated, dynamically sized vector with a maximum size of 4."],[1,"DVec5","","Stack-allocated, dynamically sized vector with a maximum size of 5."],[1,"DVec6","","Stack-allocated, dynamically sized vector with a maximum size of 6."],[1,"Iso2","","Two dimensional isometry."],[11,"rotation","","The rotation applicable by this isometry.",1],[11,"translation","","The translation applicable by this isometry.",1],[1,"Iso3","","Three dimensional isometry."],[11,"rotation","","The rotation applicable by this isometry.",2],[11,"translation","","The translation applicable by this isometry.",2],[1,"Iso4","","Four dimensional isometry."],[11,"rotation","","The rotation applicable by this isometry.",3],[11,"translation","","The translation applicable by this isometry.",3],[1,"Mat1","","Square matrix of dimension 1."],[11,"m11","","",4],[1,"Mat2","","Square matrix of dimension 2."],[11,"m11","","",5],[11,"m21","","",5],[11,"m12","","",5],[11,"m22","","",5],[1,"Mat3","","Square matrix of dimension 3."],[11,"m11","","",6],[11,"m21","","",6],[11,"m31","","",6],[11,"m12","","",6],[11,"m22","","",6],[11,"m32","","",6],[11,"m13","","",6],[11,"m23","","",6],[11,"m33","","",6],[1,"Mat4","","Square matrix of dimension 4."],[11,"m11","","",7],[11,"m21","","",7],[11,"m31","","",7],[11,"m41","","",7],[11,"m12","","",7],[11,"m22","","",7],[11,"m32","","",7],[11,"m42","","",7],[11,"m13","","",7],[11,"m23","","",7],[11,"m33","","",7],[11,"m43","","",7],[11,"m14","","",7],[11,"m24","","",7],[11,"m34","","",7],[11,"m44","","",7],[1,"Mat5","","Square matrix of dimension 5."],[11,"m11","","",8],[11,"m21","","",8],[11,"m31","","",8],[11,"m41","","",8],[11,"m51","","",8],[11,"m12","","",8],[11,"m22","","",8],[11,"m32","","",8],[11,"m42","","",8],[11,"m52","","",8],[11,"m13","","",8],[11,"m23","","",8],[11,"m33","","",8],[11,"m43","","",8],[11,"m53","","",8],[11,"m14","","",8],[11,"m24","","",8],[11,"m34","","",8],[11,"m44","","",8],[11,"m54","","",8],[11,"m15","","",8],[11,"m25","","",8],[11,"m35","","",8],[11,"m45","","",8],[11,"m55","","",8],[1,"Mat6","","Square matrix of dimension 6."],[11,"m11","","",9],[11,"m21","","",9],[11,"m31","","",9],[11,"m41","","",9],[11,"m51","","",9],[11,"m61","","",9],[11,"m12","","",9],[11,"m22","","",9],[11,"m32","","",9],[11,"m42","","",9],[11,"m52","","",9],[11,"m62","","",9],[11,"m13","","",9],[11,"m23","","",9],[11,"m33","","",9],[11,"m43","","",9],[11,"m53","","",9],[11,"m63","","",9],[11,"m14","","",9],[11,"m24","","",9],[11,"m34","","",9],[11,"m44","","",9],[11,"m54","","",9],[11,"m64","","",9],[11,"m15","","",9],[11,"m25","","",9],[11,"m35","","",9],[11,"m45","","",9],[11,"m55","","",9],[11,"m65","","",9],[11,"m16","","",9],[11,"m26","","",9],[11,"m36","","",9],[11,"m46","","",9],[11,"m56","","",9],[11,"m66","","",9],[1,"Rot2","","Two dimensional rotation matrix."],[1,"Rot3","","Three dimensional rotation matrix."],[1,"Rot4","","Four dimensional rotation matrix."],[1,"Vec0","","Vector of dimension 0."],[1,"Vec1","","Vector of dimension 1."],[11,"x","","First component of the vector.",10],[1,"Vec2","","Vector of dimension 2."],[11,"x","","First component of the vector.",11],[11,"y","","Second component of the vector.",11],[1,"Vec3","","Vector of dimension 3."],[11,"x","","First component of the vector.",12],[11,"y","","Second component of the vector.",12],[11,"z","","Third component of the vector.",12],[1,"Vec4","","Vector of dimension 4."],[11,"x","","First component of the vector.",13],[11,"y","","Second component of the vector.",13],[11,"z","","Third component of the vector.",13],[11,"w","","Fourth component of the vector.",13],[1,"Vec5","","Vector of dimension 5."],[11,"x","","First component of the vector.",14],[11,"y","","Second component of the vector.",14],[11,"z","","Third component of the vector.",14],[11,"w","","Fourth component of the vector.",14],[11,"a","","Fifth of the vector.",14],[1,"Vec6","","Vector of dimension 6."],[11,"x","","First component of the vector.",15],[11,"y","","Second component of the vector.",15],[11,"z","","Third component of the vector.",15],[11,"w","","Fourth component of the vector.",15],[11,"a","","Fifth of the vector.",15],[11,"b","","Sixth component of the vector.",15],[2,"PartialOrdering","","Result of a partial ordering."],[12,"PartialLess","","Result of a strict comparison.",16],[12,"PartialEqual","","Equality relationship.",16],[12,"PartialGreater","","Result of a strict comparison.",16],[12,"NotComparable","","Result of a comparison between two objects that are not comparable.",16],[3,"qr","","QR decomposition using Householder reflections."],[3,"eigen_qr","","Eigendecomposition of a square matrix using the qr algorithm."],[3,"householder_matrix","","Get the householder matrix corresponding to a reflexion to the hyperplane\ndefined by `vec`. It can be a reflexion contained in a subspace."],[3,"clamp","","Change the input value to ensure it is on the range `[min, max]`."],[3,"max","","Same as `cmp::max`."],[3,"min","","Same as `cmp::min`."],[3,"inf","","Returns the infimum of `a` and `b`."],[3,"sup","","Returns the supremum of `a` and `b`."],[3,"partial_cmp","","Compare `a` and `b` using a partial ordering relation."],[3,"partial_lt","","Returns `true` iff `a` and `b` are comparable and `a < b`."],[3,"partial_le","","Returns `true` iff `a` and `b` are comparable and `a <= b`."],[3,"partial_gt","","Returns `true` iff `a` and `b` are comparable and `a > b`."],[3,"partial_ge","","Returns `true` iff `a` and `b` are comparable and `a >= b`."],[3,"partial_min","","Return the minimum of `a` and `b` if they are comparable."],[3,"partial_max","","Return the maximum of `a` and `b` if they are comparable."],[3,"partial_clamp","","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to\n`min` or `max`."],[3,"identity","","Create a special identity object."],[3,"zero","","Create a zero-valued value."],[3,"one","","Create a one-valued value."],[3,"perspective3d","","Computes a projection matrix given the frustrum near plane width, height, the field of\nview, and the distance to the clipping planes (`znear` and `zfar`)."],[3,"translation","","Gets the translation applicable by `m`."],[3,"inv_translation","","Gets the inverse translation applicable by `m`."],[3,"append_translation","","Applies the translation `v` to a copy of `m`."],[3,"translate","","Applies a translation to a vector."],[3,"inv_translate","","Applies an inverse translation to a vector."],[3,"rotation","","Gets the rotation applicable by `m`."],[3,"inv_rotation","","Gets the inverse rotation applicable by `m`."],[3,"append_rotation","","Applies the rotation `v` to a copy of `m`."],[3,"prepend_rotation","","Pre-applies the rotation `v` to a copy of `m`."],[3,"rotate","","Applies a rotation to a vector."],[3,"inv_rotate","","Applies an inverse rotation to a vector."],[3,"append_rotation_wrt_point","","Rotates a copy of `m` by `amount` using `center` as the pivot point."],[3,"append_rotation_wrt_center","","Rotates a copy of `m` by `amount` using `m.translation()` as the pivot point."],[3,"to_rot_mat","","Builds a rotation matrix from `r`."],[3,"absolute_rotate","","Applies a rotation using the absolute values of its components."],[3,"transformation","","Gets the transformation applicable by `m`."],[3,"inv_transformation","","Gets the inverse transformation applicable by `m`."],[3,"append_transformation","","Gets a transformed copy of `m`."],[3,"transform","","Applies a transformation to a vector."],[3,"inv_transform","","Applies an inverse transformation to a vector."],[3,"dot","","Computes the dot product of two vectors."],[3,"sub_dot","","Computes a subtraction followed by a dot product."],[3,"norm","","Computes the L2 norm of a vector."],[3,"sqnorm","","Computes the squared L2 norm of a vector."],[3,"normalize","","Gets the normalized version of a vector."],[3,"det","","Computes the determinant of a square matrix."],[3,"cross","","Computes the cross product of two vectors."],[3,"cross_matrix","","Given a vector, computes the matrix which, when multiplied by another vector, computes a cross\nproduct."],[3,"to_homogeneous","","Converts a matrix or vector to homogeneous coordinates."],[3,"from_homogeneous","","Converts a matrix or vector from homogeneous coordinates."],[3,"sample_sphere","","Samples the unit sphere living on the dimension as the samples types."],[3,"approx_eq","","Tests approximate equality."],[3,"approx_eq_eps","","Tests approximate equality using a custom epsilon."],[3,"abs","","Computes a component-wise absolute value."],[3,"inv","","Gets an inverted copy of a matrix."],[3,"transpose","","Gets a transposed copy of a matrix."],[3,"outer","","Computes the outer product of two vectors."],[3,"cov","","Computes the covariance of a set of observations."],[3,"mean","","Computes the mean of a set of observations."],[3,"new_identity","","Construct the identity matrix for a given dimension"],[3,"canonical_basis","","Computes the canonical basis for a given dimension."],[3,"orthonormal_subspace_basis","","Computes the basis of the orthonormal subspace of a given vector."],[3,"diag","","Gets the diagonal of a square matrix."],[3,"dim","","Gets the dimension an object lives in."],[3,"cast","","Converts an object from one type to another."],[0,"overload","","Traits to work around the language limitations related to operator overloading."],[6,"Vec1MulRhs","nalgebra::na::overload",""],[9,"binop","","Applies the binary operation represented by this trait.",17],[6,"Vec2MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",18],[6,"Vec3MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",19],[6,"Vec4MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",20],[6,"Vec5MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",21],[6,"Vec6MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",22],[6,"Vec1DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",23],[6,"Vec2DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",24],[6,"Vec3DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",25],[6,"Vec4DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",26],[6,"Vec5DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",27],[6,"Vec6DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",28],[6,"Vec1AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",29],[6,"Vec2AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",30],[6,"Vec3AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",31],[6,"Vec4AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",32],[6,"Vec5AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",33],[6,"Vec6AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",34],[6,"Vec1SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",35],[6,"Vec2SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",36],[6,"Vec3SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",37],[6,"Vec4SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",38],[6,"Vec5SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",39],[6,"Vec6SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",40],[6,"Mat1MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",41],[6,"Mat2MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",42],[6,"Mat3MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",43],[6,"Mat4MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",44],[6,"Mat5MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",45],[6,"Mat6MulRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",46],[6,"Mat1DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",47],[6,"Mat2DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",48],[6,"Mat3DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",49],[6,"Mat4DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",50],[6,"Mat5DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",51],[6,"Mat6DivRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",52],[6,"Mat1AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",53],[6,"Mat2AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",54],[6,"Mat3AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",55],[6,"Mat4AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",56],[6,"Mat5AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",57],[6,"Mat6AddRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",58],[6,"Mat1SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",59],[6,"Mat2SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",60],[6,"Mat3SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",61],[6,"Mat4SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",62],[6,"Mat5SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",63],[6,"Mat6SubRhs","",""],[9,"binop","","Applies the binary operation represented by this trait.",64],[6,"Absolute","nalgebra::na","Trait of objects having an absolute value.\nThis is useful if the object does not have the same type as its absolute value."],[9,"abs","","Computes some absolute value of this object.\nTypically, this will make all component of a matrix or vector positive.",65],[6,"AbsoluteRotate","","Composition of a rotation and an absolute value."],[9,"absolute_rotate","","This is the same as:",66],[6,"AnyVec","","Trait grouping most common operations on vectors."],[6,"ApproxEq","","Trait for testing approximate equality"],[9,"approx_epsilon","","Default epsilon for approximation.",67],[9,"approx_eq_eps","","Tests approximate equality using a custom epsilon.",67],[10,"approx_eq","","Tests approximate equality.",67],[6,"Basis","","Traits of objects which can form a basis (typically vectors)."],[9,"canonical_basis","","Iterates through the canonical basis of the space in which this object lives.",68],[9,"orthonormal_subspace_basis","","Iterates through a basis of the subspace orthogonal to `self`.",68],[6,"Cast","","Traits of objects which can be created from an object of type `T`."],[9,"from","","Converts an element of type `T` to an element of type `Self`.",69],[6,"Col","","Trait to access columns of a matrix or vector."],[9,"ncols","","The number of column of this matrix or vector.",70],[9,"col","","Reads the `i`-th column of `self`.",70],[9,"set_col","","Writes the `i`-th column of `self`.",70],[6,"ColSlice","","Trait to access part of a column of a matrix"],[9,"col_slice","","Returns a view to a slice of a column of a matrix.",71],[6,"RowSlice","","Trait to access part of a row of a matrix"],[9,"row_slice","","Returns a view to a slice of a row of a matrix.",72],[6,"Cov","","Trait for computing the covariance of a set of data."],[9,"cov","","Computes the covariance of the obsevations stored by `m`:",73],[10,"cov_to","","Computes the covariance of the obsevations stored by `m`:",73],[6,"Cross","","Trait of elements having a cross product."],[9,"cross","","Computes the cross product between two elements (usually vectors).",74],[6,"CrossMatrix","","Trait of elements having a cross product operation which can be expressed as a matrix."],[9,"cross_matrix","","The matrix associated to any cross product with this vector. I.e. `v.cross(anything)` =\n`v.cross_matrix().rmul(anything)`.",75],[6,"Det","","Trait of objects having a determinant. Typically used by square matrices."],[9,"det","","Returns the determinant of `m`.",76],[6,"Diag","","Trait to get the diagonal of square matrices."],[9,"from_diag","","Creates a new matrix with the given diagonal.",77],[9,"set_diag","","Sets the diagonal of this matrix.",77],[9,"diag","","The diagonal of this matrix.",77],[6,"Dim","","Trait of objects having a spacial dimension known at compile time."],[9,"dim","","The dimension of the object.",78],[6,"Dot","","Traits of objects having a dot product."],[9,"dot","","Computes the dot (inner) product of two vectors.",79],[9,"sub_dot","","Short-cut to compute the projection of a point on a vector, but without\ncomputing intermediate vectors.\nThe following equation must be verified:",79],[6,"Eye","","Trait for constructing the identity matrix"],[9,"new_identity","","Return the identity matrix of specified dimension",80],[6,"FloatVec","","Trait of vector with components implementing the `Float` trait."],[6,"FloatVecExt","","Trait grouping uncommon, low-level and borderline (from the mathematical point of view)\noperations on vectors."],[6,"FromHomogeneous","","Traits of objects which can be build from an homogeneous coordinate form."],[9,"from","","Builds an object from its homogeneous coordinate form.",81],[6,"Indexable","","This is a workaround of current Rust limitations."],[9,"at","","Reads the `i`-th element of `self`.",82],[9,"set","","Writes to the `i`-th element of `self`.",82],[9,"swap","","Swaps the `i`-th element of `self` with its `j`-th element.",82],[9,"shape","","Returns the shape of the iterable range.",82],[9,"unsafe_at","","Reads the `i`-th element of `self`.",82],[9,"unsafe_set","","Writes to the `i`-th element of `self`.",82],[6,"Inv","","Trait of objects having an inverse. Typically used to implement matrix inverse."],[9,"inv_cpy","","Returns the inverse of `m`.",83],[9,"inv","","In-place version of `inverse`.",83],[6,"Iterable","","This is a workaround of current Rust limitations."],[9,"iter","","Gets a vector-like read-only iterator.",84],[6,"IterableMut","","This is a workaround of current Rust limitations."],[9,"mut_iter","","Gets a vector-like read-write iterator.",85],[6,"LMul","","Trait of objects having a left multiplication with another element."],[9,"lmul","","Computes `v * self`",86],[6,"Mat","","Trait of matrices."],[6,"Mean","","Trait for computing the covariance of a set of data."],[9,"mean","","Computes the mean of the observations stored by `v`.\n \n  * For matrices, observations are stored in its rows.\n  * For vectors, observations are stored in its components (thus are 1-dimensional).",87],[6,"Norm","","Traits of objects having an euclidian norm."],[10,"norm","","Computes the norm of `self`.",88],[9,"sqnorm","","Computes the squared norm of `self`.",88],[9,"normalize_cpy","","Gets the normalized version of a copy of `v`.",88],[9,"normalize","","Normalizes `self`.",88],[6,"Outer","","Traits of objects having an outer product."],[9,"outer","","Computes the outer product: `a * b`",89],[6,"PartialOrd","","Pointwise ordering operations."],[9,"inf","","Returns the infimum of `a` and `b`.",90],[9,"sup","","Returns the supremum of `a` and `b`.",90],[9,"partial_cmp","","Compare `a` and `b` using a partial ordering relation.",90],[10,"partial_le","","Returns `true` iff `a` and `b` are comparable and `a <= b`.",90],[10,"partial_lt","","Returns `true` iff `a` and `b` are comparable and `a < b`.",90],[10,"partial_ge","","Returns `true` iff `a` and `b` are comparable and `a >= b`.",90],[10,"partial_gt","","Returns `true` iff `a` and `b` are comparable and `a > b`.",90],[10,"partial_min","","Return the minimum of `a` and `b` if they are comparable.",90],[10,"partial_max","","Return the maximum of `a` and `b` if they are comparable.",90],[10,"partial_clamp","","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to\n`min` or `max`.",90],[6,"RMul","","Trait of objects having a right multiplication with another element."],[9,"rmul","","Computes `self * v`",91],[6,"Rotate","","Trait of objects able to rotate other objects."],[9,"rotate","","Applies a rotation to `v`.",92],[9,"inv_rotate","","Applies an inverse rotation to `v`.",92],[6,"Rotation","","Trait of object which can represent a rotation, and to which new rotations can be appended. A\nrotation is assumed to be an isometry without translation and without reflexion."],[9,"rotation","","Gets the rotation associated with `self`.",93],[9,"inv_rotation","","Gets the inverse rotation associated with `self`.",93],[9,"append_rotation","","Appends a rotation to this object.",93],[9,"append_rotation_cpy","","Appends the rotation `amount` to a copy of `t`.",93],[9,"prepend_rotation","","Prepends a rotation to this object.",93],[9,"prepend_rotation_cpy","","Prepends the rotation `amount` to a copy of `t`.",93],[9,"set_rotation","","Sets the rotation of `self`.",93],[6,"RotationMatrix","","Trait of transformation having a rotation extractable as a rotation matrix. This can typically\nbe implemented by quaternions to convert them to a rotation matrix."],[9,"to_rot_mat","","Gets the rotation matrix represented by `self`.",94],[6,"RotationWithTranslation","","Various composition of rotation and translation."],[10,"append_rotation_wrt_point_cpy","","Applies a rotation centered on a specific point.",95],[10,"append_rotation_wrt_point","","Rotates `self` using a specific center of rotation.",95],[10,"append_rotation_wrt_center_cpy","","Applies a rotation centered on the translation of `m`.\n \n# Arguments\n  * `t` - the object to be rotated.\n  * `amount` - the rotation to apply.",95],[10,"append_rotation_wrt_center","","Applies a rotation centered on the translation of `m`.",95],[6,"Row","","Trait to access rows of a matrix or a vector."],[9,"nrows","","The number of column of `self`.",96],[9,"row","","Reads the `i`-th row of `self`.",96],[9,"set_row","","Writes the `i`-th row of `self`.",96],[6,"ScalarAdd","","Trait of objects having an addition with a scalar."],[9,"add_s","","Gets the result of `self + n`.",97],[6,"ScalarSub","","Trait of objects having a subtraction with a scalar."],[9,"sub_s","","Gets the result of `self - n`.",98],[6,"ScalarMul","","Trait of objects having a multiplication with a scalar."],[9,"mul_s","","Gets the result of `self * n`.",99],[6,"ScalarDiv","","Trait of objects having a division by a scalar."],[9,"div_s","","Gets the result of `self / n`.",100],[6,"ToHomogeneous","","Traits of objects which can be put in homogeneous coordinates form."],[9,"to_homogeneous","","Gets the homogeneous coordinates form of this object.",101],[6,"Transform","","Trait of objects able to transform other objects."],[9,"transform","","Applies a transformation to `v`.",102],[9,"inv_transform","","Applies an inverse transformation to `v`.",102],[6,"Transformation","","Trait of object which represent a transformation, and to which new transformations can\nbe appended."],[9,"transformation","","Gets the transformation of `self`.",103],[9,"inv_transformation","","Gets the inverse transformation of `self`.",103],[9,"append_transformation","","Appends a transformation to this object.",103],[9,"append_transformation_cpy","","Appends the transformation `amount` to a copy of `t`.",103],[9,"prepend_transformation","","Prepends a transformation to this object.",103],[9,"prepend_transformation_cpy","","Prepends the transformation `amount` to a copy of `t`.",103],[9,"set_transformation","","Sets the transformation of `self`.",103],[6,"Translate","","Trait of objects able to rotate other objects. This is typically implemented by matrices which\nrotate vectors."],[9,"translate","","Apply a translation to an object.",104],[9,"inv_translate","","Apply an inverse translation to an object.",104],[6,"Translation","","Trait of object which represent a translation, and to wich new translation\ncan be appended."],[9,"translation","","Gets the translation associated with this object.",105],[9,"inv_translation","","Gets the inverse translation associated with this object.",105],[9,"append_translation","","Appends a translation to this object.",105],[9,"append_translation_cpy","","Appends the translation `amount` to a copy of `t`.",105],[9,"prepend_translation","","Prepends a translation to this object.",105],[9,"prepend_translation_cpy","","Prepends the translation `amount` to a copy of `t`.",105],[9,"set_translation","","Sets the translation.",105],[6,"Transpose","","Trait of objects which can be transposed."],[9,"transpose_cpy","","Computes the transpose of a matrix.",106],[9,"transpose","","In-place version of `transposed`.",106],[6,"UniformSphereSample","","Trait of vectors able to sample a unit sphere."],[9,"sample","","Iterate through the samples.",107],[6,"VecExt","","Trait grouping uncommon, low-level and borderline (from the mathematical point of view)\noperations on vectors."]],"paths":[[1,"DVec"],[1,"Iso2"],[1,"Iso3"],[1,"Iso4"],[1,"Mat1"],[1,"Mat2"],[1,"Mat3"],[1,"Mat4"],[1,"Mat5"],[1,"Mat6"],[1,"Vec1"],[1,"Vec2"],[1,"Vec3"],[1,"Vec4"],[1,"Vec5"],[1,"Vec6"],[2,"PartialOrdering"],[6,"Vec1MulRhs"],[6,"Vec2MulRhs"],[6,"Vec3MulRhs"],[6,"Vec4MulRhs"],[6,"Vec5MulRhs"],[6,"Vec6MulRhs"],[6,"Vec1DivRhs"],[6,"Vec2DivRhs"],[6,"Vec3DivRhs"],[6,"Vec4DivRhs"],[6,"Vec5DivRhs"],[6,"Vec6DivRhs"],[6,"Vec1AddRhs"],[6,"Vec2AddRhs"],[6,"Vec3AddRhs"],[6,"Vec4AddRhs"],[6,"Vec5AddRhs"],[6,"Vec6AddRhs"],[6,"Vec1SubRhs"],[6,"Vec2SubRhs"],[6,"Vec3SubRhs"],[6,"Vec4SubRhs"],[6,"Vec5SubRhs"],[6,"Vec6SubRhs"],[6,"Mat1MulRhs"],[6,"Mat2MulRhs"],[6,"Mat3MulRhs"],[6,"Mat4MulRhs"],[6,"Mat5MulRhs"],[6,"Mat6MulRhs"],[6,"Mat1DivRhs"],[6,"Mat2DivRhs"],[6,"Mat3DivRhs"],[6,"Mat4DivRhs"],[6,"Mat5DivRhs"],[6,"Mat6DivRhs"],[6,"Mat1AddRhs"],[6,"Mat2AddRhs"],[6,"Mat3AddRhs"],[6,"Mat4AddRhs"],[6,"Mat5AddRhs"],[6,"Mat6AddRhs"],[6,"Mat1SubRhs"],[6,"Mat2SubRhs"],[6,"Mat3SubRhs"],[6,"Mat4SubRhs"],[6,"Mat5SubRhs"],[6,"Mat6SubRhs"],[6,"Absolute"],[6,"AbsoluteRotate"],[6,"ApproxEq"],[6,"Basis"],[6,"Cast"],[6,"Col"],[6,"ColSlice"],[6,"RowSlice"],[6,"Cov"],[6,"Cross"],[6,"CrossMatrix"],[6,"Det"],[6,"Diag"],[6,"Dim"],[6,"Dot"],[6,"Eye"],[6,"FromHomogeneous"],[6,"Indexable"],[6,"Inv"],[6,"Iterable"],[6,"IterableMut"],[6,"LMul"],[6,"Mean"],[6,"Norm"],[6,"Outer"],[6,"PartialOrd"],[6,"RMul"],[6,"Rotate"],[6,"Rotation"],[6,"RotationMatrix"],[6,"RotationWithTranslation"],[6,"Row"],[6,"ScalarAdd"],[6,"ScalarSub"],[6,"ScalarMul"],[6,"ScalarDiv"],[6,"ToHomogeneous"],[6,"Transform"],[6,"Transformation"],[6,"Translate"],[6,"Translation"],[6,"Transpose"],[6,"UniformSphereSample"]]};

searchIndex['dim2'] = {"items":[],"paths":[]};

searchIndex['dim3'] = {"items":[],"paths":[]};

initSearch(searchIndex);
